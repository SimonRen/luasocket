<html>

<head>
<style type="text/css">
ul { list-style-type: disc };
</style>
</head>

<body bgcolor="#FFFFFF">

<hr>

<center>
<table border=0 cellspacing=0 cellpadding=0>
<tr><td align=center>
<a href="http://www.lua.org">
<img border=0 alt="The Lua language" src="lua.png">
</a>
<tr><td align=center><big><b>LuaSocket</b></big>
<tr><td align=center valign=top>IPv4 Sockets support for the Lua language
</table>
</center>

<p>

<center>
<a href=#whatis>what is</a> &middot;
<a href=#intro>introduction</a> &middot;
<a href=#old>old versions</a> &middot;
<a href=#current>current version</a> &middot;
<a href=#refman>functions</a> &middot;
<a href=#proto>protocols</a> 
</center>

<p>

<hr>

<h2> Contents </h2><p>

<ul>
<li> <a href=#whatis>What is LuaSocket</a> 
        <ul>
        <li> <a href=#old>Old Versions</a>
        <li> <a href=#current>Current Version</a>
        <li><a href=#new>What's New</a>
        <li><a href=#incompat>Incompatibilities with previous versions</a>
        <li><a href=#down>Download</a>
        </ul>
<li> <a href=#intro>Introduction</a>
        <ul>
        <li><a href=#init>Initializing the library</a>
        <li><a href=#prog>Network programming with LuaSocket</a>
            <ul>
            <li> <a href=#TCPprog>TCP programming</a>
            <li> <a href=#UDPprog>UDP programming</a>
            </ul>
        </ul>
<li> <a href=#refman>Function Reference</a>
    <ul>
    <li> <a href=#tcpman>TCP sockets</a>
        <ul>
        <li> <a href=#tcpaccept>accept</a>
        <li> <a href=#tcpbind>bind</a>
        <li> <a href=#tcpclose>close</a>
        <li> <a href=#tcpconnect>connect</a>
        <li> <a href=#tcpgetpeername>getpeername</a>
        <li> <a href=#tcpgetsockname>getsockname</a>
        <li> <a href=#tcpreceive>receive</a>
        <li> <a href=#tcpselect>select</a>
        <li> <a href=#tcpsend>send</a>
        <li> <a href=#tcptimeout>timeout</a>
        </ul>
    <li> <a href=#udpman>UDP sockets</a>
        <ul>
        <li> <a href=#udpclose>close</a>
        <li> <a href=#udpgetpeername>getpeername</a>
        <li> <a href=#udpgetsockname>getsockname</a>
        <li> <a href=#udpreceive>receive</a>
        <li> <a href=#udpreceivefrom>receivefrom</a>
        <li> <a href=#udpselect>select</a>
        <li> <a href=#udpsend>send</a>
        <li> <a href=#udpsendto>sendto</a>
        <li> <a href=#udpsetpeername>setpeername</a>
        <li> <a href=#udpsetsockname>setsockname</a>
        <li> <a href=#udptimeout>timeout</a>
        <li> <a href=#udpsocket>udpsocket</a>
        </ul>
    <li> <a href=#dnsman>DNS services</a>
        <ul>
        <li> <a href=#toip>toip</a>
        <li> <a href=#toip>tohostname</a>
        </ul>
    </ul>
<li> <a href=#proto>Protocol Reference</a>
    <ul>
    <li> <a href=#smtp>SMTP</a>
        <ul>
        <li> <a href=#smtp_mail>smtp_mail</a>
        <li> <a href=#mail>mail</a>
        </ul>
    <li> <a href=#stream>Streaming with callbacks</a>
        <ul>
        <li> <a href=#receive_cb>receive_cb</a>
        <li> <a href=#send_cb>send_cb</a>
        </ul>
    <li> <a href=#http>HTTP</a>
        <ul>
        <li> <a href=#http_request>http_request</a>
        <li> <a href=#http_get>http_get</a>
        <li> <a href=#http_post>http_post</a>
        <li> <a href=#http_requestindirect>http_requestindirect</a>
        <li> <a href=#http_getindirect>http_getindirect</a>
        <li> <a href=#http_postindirect>http_postindirect</a>
        </ul>
    <li> <a href=#ftp>FTP</a>
        <ul>
        <li> <a href=#ftp_get>ftp_get</a>
        <li> <a href=#ftp_put>ftp_put</a>
        <li> <a href=#ftp_getindirect>ftp_getindirect</a>
        <li> <a href=#ftp_putindirect>ftp_putindirect</a>
        </ul>
    </ul>
</ul>
<br>

<h2> <a name=whatis> What is LuaSocket? </h2><p>

LuaSocket   is  a   <a  href="http://www.lua.org">Lua</a>
extension library  that provides support  for the TCP and  UDP transport
layers within  the Lua language.  The library also provides  support for
SMTP  (sending  e-mails),  HTTP  (www access)  and  FTP  (uploading  and
downloading files).<p>

LuaSocket can be used by any  Lua application desiring access to network
communication on the Internet, once it has been properly linked with and
initialized by the interpreter running the Lua application. The code has
been tested and runs well on several Windows and Unix platforms.<p>

The library is available under the same  
<a href="http://www.lua.org/copyright.html">
terms and conditions</a> as the Lua language, that  is, it  can be  used 
at  no cost  for both  academic and commercial purposes. <p>

Copyright &copy; 1999-2001 TeCGraf, PUC-Rio. All rights reserved. <br>
Author: <A href="http://www.tecgraf.puc-rio.br/~diego">Diego Nehab</a><p>

<h3> <a name=old>Old Versions</h3><p>

All  previous versions  of the  LuaSocket library  can be  downloaded 
<a href="http://www.tecgraf.puc-rio.br/luasocket/old">here</a>. Although
these  versions are  no longer  supported, they  are still available for
those that have compatibility issues. <p>


<h3> <a name=current>Current Version</h3><p>

LuaSocket version  1.3b is now  available for download! It  is compatible
with   Lua&nbsp;4.0   and   has    been   tested   on   Windows&nbsp;98,
Windows&nbsp;2000, Linux, AIX, SunOS and IRIX. <p>

<h3><a name=new>What's New</h3><p>

The major  improvements over previous versions  are in the HTTP  and FTP
support. Users have the ability to download and upload information chunk
by  chunk, so  that  the amount  of  memory spent  in  transfers can  be
bounded. There have also been some bug-fixes:

<ul>
<li> HTTP and FTP code now support streaming with a callback system.
<li> Users can now prevent HTTP request code from automatically following 
     a 301 or 302 redirect server reply;
<li> UDP sockets can have non-default socket options defined at creation
     time (<tt>SO_BROADCAST</tt>, <tt>SO_LINGER</tt> etc);
<li> Bug-fix: select was crashing on invalid input (ex. closed sockets);
<li> Bug-fix: SMTP code was not dealing correctly with folded server replies, 
     as defined in Appendix E of RFC 821.
</ul>

<h3><a name=incompat>Incompatibilities with previous versions</h3><p>

There should be no incompatibilities.

<h3><a name=down> Download </h3><p>

The library can be downloaded in source code from the following links: <p>

<a href="luasocket-1.3b.tar.gz">luasocket-1.3b.tar.gz</a> <br>
<a href="luasocket-1.3b.zip">luasocket-1.3b.zip</a> <p>

Besides the full C and Lua source code for the library, the distribution
contains several examples,  this user's manual and  the test procedures.
<p>

<h2> <a name=intro> Introduction </h2><p>

Below is a little introduction on how  to get the library up and running
with your applications and a  little introduction on network programming
with LuaSocket.

<h3> <a name=init> Initializing the library </h3><p>

To  have the  library  functions made  available to  a  Lua script,  the
interpreter running the script must  be linked to the <tt>luasocket</tt>
library, and  to whatever libraries  the OS  in use requires  for socket
programming. The functions are registered in  the Lua state given as the
parameter  to  the  function   <tt>lua_socketlibopen</tt>,  the  only  C
function  exported  by  the  library.  The  scripts  can  then  use  all
registered functions. <p>

<h3> <a name=prog> Network programming with LuaSocket </h3><p>

The network support  in the Lua language could closely  mirror the C API
or  could implement  a  new, independent,  transport layer  abstraction.
Having an API  similar to the C  API would make things  easier for those
who are used to socket programming. On the other hand, the simplicity of
the Lua language  would be lost. We ended up  with something in between,
in the sense that function names and semantics have been copied from the
C API  whenever possible, whereas  their usage  in Lua has  been greatly
simplified. <p>

One of the  major differences in the created API  is the timeout control
provided by the library. All I/O  operations are blocking by default. In
other  words, the  <tt>send</tt>,  <tt>receive</tt> and  <tt>accept</tt>
functions  will block  the  caller application  until  the operation  is
completed (if ever). The application  can, however, specify upper limits
on the time it can  be blocked by LuaSocket ("<tt>return</tt>" timeout),
on  the time  LuaSocket can  be  blocked by  the OS  ("<tt>blocked</tt>"
timeout) or a combination of the  two. Remember that each LuaSocket call
performs several OS calls, so that the two timeout values are <i>not</i>
equivalent. <p>

Another major difference is the receive pattern capability. Applications
can read  data from a  TCP client socket line  by line, chunk  by chunk,
until the connection  is closed etc. All I/O reads  are buffered and the
performance difference between different receive patterns is negligible.
<p>

Finally,  host  name  resolution   is  transparent,  meaning  that  most
functions accept both  IP addresses and host names. In  case a host name
is  given, the  library  queries the  system's  resolver  and tries  all
returned IP addresses  until one succeeds or all fail.  IP addresses are
directly encoded and are therefore more efficient. The <tt>toip</tt> and
<tt>tohostname</tt> functions are provided to convert between host names
and IP addresses. <p>

Socket objects are represented as  tables in the Lua language. Different
socket types accept different operations. These operations are available
both as stand-alone global functions and  as table methods of the socket
objects    (i.e.    the    calls   <tt>send(sock,    "test")</tt>    and
<tt>sock:send("test")</tt>  are  equivalent). It  is  considered  better
style to  use the table  method versions,  which are also  slightly more
efficient. <p>

<a name=TCPprog><b>TCP programming</b><p>

TCP is a reliable stream protocol. In other words, applications send and
receive data as an error free stream of  bytes. Data is split in one end
and reassembled transparently on the  other end. There are no boundaries
in the  data transfers. The library  allows users to read  data from the
sockets in  several different granuralities: patterns  are available for
words, lines, arbitrary sized blocks  or "read up to connection closed",
all with similar performance. <p>

The library distinguishes  two types of TCP sockets:  client sockets and
server sockets. <p>

Client sockets are  used to exchange data between  two applications over
the Internet. Client sockets are  created by the <tt>connect</tt> global
function  or  returned  by  the <tt>accept</tt>  server  socket  method.
Applications can call the  methods <tt>send</tt> and <tt>receive</tt> to
send and  receive data.  The other methods  available for  client socket
objects are <tt>getsockname</tt>, <tt>getpeername</tt>, <tt>timeout</tt>
and <tt>close</tt>.<p>

Server sockets are created by  the <tt>bind</tt> global function and are
associated with a  address and port on the local  host. Applications use
the <tt>accept</tt> server socket method to wait for a client connection
on a  server socket. Once a  connection is established, a  client socket
object  is  returned representing  this  connection.  The other  methods
available   for   server   socket  objects   are   <tt>getsockname</tt>,
<tt>timeout</tt> and <tt>close</tt>. <p>

<a name=UDPprog><b>UDP programming</b><p>

UDP is  a non-reliable datagram  protocol. In other  words, applications
send and receive data as independent blocks, which are not guaranteed to
reach the other  end. Even when they  reach the other end,  they are not
guaranteed to be error free. Data  transfers are atomic, one datagram at
a time. Reading only  part of a datagram discards the  rest, so that the
next read operation will act on the next datagram. The advantages are in
simplicity (no connection  setup) and performance (no  error checking or
error correction). <p>

An UDP socket object is  created by the <tt>udpcreate</tt> function. UDP
sockets  do   not  need   to  be  connected   before  use.   The  method
<tt>sendto</tt>  can  be  used  immediately after  creation  to  send  a
datagram to  any UDP  (ip, port)  pair. Host names  are not  allowed for
performance reasons.  Methods <tt>receive</tt>  and <tt>receivefrom</tt>
can be used to retrieve datagrams, the  latter returning the ip and port
of  the  sender  as  extra  return  values  (thus  being  slightly  less
efficient). <p>

When  communication  is performed  repeatedly  with  a single  peer,  an
application  should call  the <tt>setpeername</tt>  method to  specify a
permanent partner.  The method  <tt>send</tt> can then  be used  to send
data   directly  to   the   peer,  and   methods  <tt>receive</tt>   and
<tt>receivefrom</tt> will  only return  datagrams originating  from that
peer. There is about 30% performance gain due to this practice. <p>

To associate  an UDP socket with  a local address, an  application calls
the   <tt>setsockname</tt>   function.   Otherwise,    the   socket   is
automatically  bound  to an  ephemeral  address  before the  first  data
transmission.  The   other  methods   available  for  UDP   sockets  are
<tt>getpeername</tt>,    <tt>getsockname</tt>,   <tt>timeout</tt>    and
<tt>close</tt>. <p>

<h2> <a name=refman> Function Reference </h2> <p>

All the functions  of the API are described below.  Several examples are
given in  the distribution, including  the automated tests and  the full
implementation of the protocols FTP, SMTP and HTTP. <p>

Note that although some function  names are overloaded, documentation is
provided separately for TCP and UDP sockets. <p>

<h3> <a name=tcpman> TCP sockets </h3> <p>

<a name=tcpaccept><tt><b>accept(</b>socket<b>)</b></tt><p>

Waits  for  a   TCP  client  to  attempt  connection   with  the  server
<tt>socket</tt>, and  returns a  client socket  object connected  to the
remote  end.  If  a  timeout condition  is  met,  the  function  returns
<tt>nil</tt> followed by the string '<tt>timeout</tt>'. <p>

<a name=tcpbind><tt><b>bind(</b>address, port [, backlog]<b>)</b></tt><p>

Creates  a new  TCP server  socket  and binds  it to  (<tt>address</tt>,
<tt>port</tt>) on the local host.  <tt>Address</tt> can be an IP address
or a host name. If <tt>address</tt> is '<tt>*</tt>', the system binds to
all local  interfaces (<tt>INADDR_ANY</tt>). If <tt>port</tt>  is 0, the
system automatically  chooses an ephemeral port.  The optional parameter
<tt>backlog</tt>  (default  value  1)  specifies the  number  of  client
connections that can be queued waiting for service. If the queue is full
and another  client attempts connection,  the connection is  refused. In
case of  success, the  function returns  a server  socket, on  which the
operations  <tt>accept</tt>,  <tt>close</tt>,  <tt>getsockname</tt>  and
<tt>listen</tt> are  permitted. In case  of error, the  function returns
<tt>nil</tt> followed by a string describing the error. <p>

<a name=tcpclose><tt><b>close(</b>socket<b>)</b></tt><p>

Closes  the   socket  <tt>socket</tt>.   The  local  address   to  which
<tt>socket</tt> was  bound is made  available to other  applications. No
further  operations (except  for  further calls  to <tt>close</tt>)  are
allowed on a closed socket. <p>

Note:  It is  important to  close all  used  sockets once  they are  not
needed,  since, in  many systems,  each socket  uses a  file descriptor,
which are a limited system resource. <p>

<a name=tcpconnect><tt><b>connect(</b>address, port<b>)</b></tt><p>

Creates   a  new   TCP   client   socket  and   tries   to  connect   to
(<tt>address</tt>, <tt>port</tt>). <tt>Address</tt> can be an IP address
or a host name. In case of success, the function returns a client socket
on   which   the    operations   <tt>close</tt>,   <tt>getsockname</tt>,
<tt>getpeername</tt>,      <tt>receive</tt>,      <tt>send</tt>      and
<tt>timeout</tt> are permitted.  In case of error,  the function returns
<tt>nil</tt> followed by a string describing the error. <p>

<a name=tcpgetpeername><tt><b>getpeername(</b>socket<b>)</b></tt><p>

Returns the IP address and port of  the peer connected to the TCP client
<tt>socket</tt> or <tt>nil</tt> in case of  error. Note that it makes no
sense to call <tt>getpeername</tt> on a server socket object. <p>

<a name=tcpgetsockname><tt><b>getsockname(</b>socket<b>)</b></tt><p>

Returns the local IP address and port of the TCP <tt>socket</tt>
or <tt>nil</tt> in case of error. <p>

<a name=tcpreceive><tt><b>receive(</b>socket [, pattern<sub>1</sub></tt>, <tt>pattern</tt><sub>2</sub>, ... <tt>pattern</tt><sub>N</sub>]<b><tt>)</tt></b><p>

Receives <tt>pattern</tt><sub>1</sub>, <tt>pattern</tt><sub>2</sub>, ...
<tt>pattern</tt><sub>N</sub> from the  client <tt>socket</tt>. A pattern
can be one of the following:

<ul>

<li>  '<tt>*a</tt>':  reads from  the  socket  until the  connection  is
closed. No end-of-line translation is performed;

<li> '<tt>*l</tt>':  reads a line of  text from the socket.  The line is
terminated by a  LF character (ASCII&nbsp;10), optionally  preceded by a
CR character (ASCII&nbsp;13). The CR and LF characters are not returned.
This is the default pattern;

<li> '<tt>*lu</tt>': reads  a line of text from the  socket. The line is
assumed to be  terminated by a single LF character.  If the LF character
is is preceded  by a CR character,  the CR character is  returned in the
string, whereas the LF character is not;

<li> '<tt>*w</tt>':  reads a word (maximal  sequence of non-white-space
characters), skipping leading spaces if necessary;

<li> <tt>number</tt>:  causes the  function to read  <tt>number</tt> raw
bytes from the socket. 

</ul>

The function  returns one value for  each pattern, followed by  a single
error  code that  can be  <tt>nil</tt> in  case of  success, the  string
'<tt>closed</tt>'  in   case  the  connection  was   closed  before  the
transmission  was completed  or  the string  '<tt>timeout</tt>' in  case
there was a timeout during  the operation. The difference in performance
between all patterns is negligible. <p>

Note: In case of error, the function always return everything it managed
to download before the error condition was met. <p>

<a name=tcpselect><tt><b>select(</b>receive, send [, timeout]<b>)</b></tt><p>

Waits for  a number of sockets  to change status. <tt>Receive</tt>  is a
table with  the sockets  to test for  characters available  for reading.
Sockets in  the <tt>send</tt> table  are watched to see  if it is  OK to
immediately write  on them.  <tt>Timeout</tt> is  the maximum  amount of
time  (in seconds)  to  wait for  a change  in  status. A  <tt>nil</tt>,
negative or omitted <tt>timeout</tt> value  allows the function to block
indefinitely.  <tt>Receive</tt>  and  <tt>send</tt> can  also  be  empty
tables or <tt>nil</tt>. Non-socket values in the tables will be silently
ignored (that way you can have a handy field named <tt>"n"</tt>). <p>

The function returns a table with the sockets ready for reading, a table
with  the sockets  ready for  writing and  an error  message. The  error
message is  "timeout" if  a timeout condition  was met  and <tt>nil</tt>
otherwise. <p>

Important Note:  a known  bug in  WinSock prevents  <tt>select</tt> from
working properly on non-blocking TCP  sockets. The function may return a
socket as <i>writable</i> even though the socket is <i>not</i> ready for
sending. <p>

Note:   calling   <tt>select</tt>   with   a  server   socket   in   the
<tt>receive</tt>  parameter  before  a   call  to  <tt>accept</tt>  does
<i>not</i> guarantee  <tt>accept</tt> will  return immediately.  Use the
<tt>timeout</tt>  server socket  method or  <tt>accept</tt> <i>might</i>
block forever. <p>

Interesting note: as mentioned in some manuals, calling <tt>select</tt> 
with both sets empty and a non-null timeout is a fairly portable way to 
sleep with sub-second precision. <p>

Examples:

<blockquote>
<pre>
-- waits for input on three sockets and broadcasts any received lines
server = bind("localhost", 8080)
a = server:accept(); b = server:accept(); c = server:accept()
a:timeout(1); b:timeout(1); c:timeout(1)
while 1 do
  r, _, e = select({a,b,c}, nil)
  for i,v in r do
    l, e = v:receive()
    if e then exit() end
    _, s, e = select(nil, {a,b,c}, 1)
    for j,u in s do
      e = u:send(l, "\n") 
      if e then exit() end
    end
  end
end

</pre>
</blockquote>

<a name=tcpsend><tt><b>send(</b>socket, string<sub>1</sub> </tt>[, <tt>string</tt><sub>2</sub>, ... <tt>string</tt><sub>N</sub>]<b><tt>)</tt></b><p>

Sends the strings <tt>string</tt><sub>1</sub>, 
<tt>string</tt><sub>2</sub>, ... <tt>string</tt><sub>N</sub> through the
client socket <tt>socket</tt>. The function returns an error code, which
is <tt>nil</tt> in case of success, the string '<tt>closed</tt>' in case
the connection was  closed before the transmission was  completed or the
string  '<tt>timeout</tt>'  in  case  there was  a  timeout  during  the
operation.  After the  error code,  the function  returns the  number of
bytes accepted by the transport layer. <p>

<a name=tcptimeout><tt><b>timeout(</b>socket, value [, mode]<b>)</b></tt><p>

Changes the timeout  values for the socket  <tt>socket</tt>. By default,
all I/O  operations are  blocking. That  is, any  call to  the functions
<tt>send</tt> and  <tt>receive</tt> will  block indefinitely,  until the
operation completes.  The <tt>timeout</tt>  function defines a  limit on
the  amount  of   time  the  functions  can  block,   specified  as  the
<tt>value</tt> parameter,  in seconds. There  are two timeout  modes and
both can be used together for fine tuning:

<ul>
<li> '<tt>b</tt>': <i>blocked</i> timeout.  Specifies the upper limit on
the amount  of time  LuaSocket can  be blocked  by the  operating system
while waiting for completion of any single I/O operation;</li>

<li> '<tt>r</tt>':  <i>return</i> timeout. Specifies the  upper limit on
the amount of  time LuaSocket can block a Lua  script before returning a
function call.</li> </ul>

The  <tt>nil</tt>  timeout  <tt>value</tt> allows  operations  to  block
indefinitely. Negative timeout values have the same effect. <p>

Note: although  timeout values have millisecond  precision, large blocks
can cause  I/O functions not to  respect timeout values due  to the time
the library takes to  transfer blocks to and from the  kernel and to and
from the Lua interpreter. <p>

<h3> <a name=udpman> UDP sockets </h3> <p>

<a name=udpclose><tt><b>close(</b>socket<b>)</b></tt><p>

Closes  the socket  <tt>socket</tt>. The  local address  to which  it is
bound is made available to other applications. No further operations are
allowed on a closed socket. <p>

Note:  It is  important to  close all  used  sockets once  they are  not
needed,  since, in  many systems,  each socket  uses a  file descriptor,
which are a limited system resource. <p>

<a name=udpgetpeername><tt><b>getpeername(</b>socket<b>)</b></tt><p>

Returns the IP address and port of  the peer of the UDP <tt>socket</tt>.
The  function will  fail unless  a  peer has  been  set with  a call  to
<tt>setpeername</tt>. <p>

<a name=udpgetsockname><tt><b>getsockname(</b>socket<b>)</b></tt><p>

Returns the  local IP  address and  port of  the TCP  <tt>socket</tt> or
<tt>nil</tt> in case of error. <p>

Note:   UDP   sockets    are   not   bound   to    any   address   until
<tt>setsockname</tt>  or the  <tt>sendto</tt> method  is called  for the
first time  (in which  case it  is bound  to an  ephemeral port  and the
wild-card address). The local address cannot be changed thereafter. <p>

<a name=udpreceive><tt><b>receive(</b>socket [, number]<b>)</b></tt><p>

Receives  a datagram  from the  UDP  socket <tt>socket</tt>  with up  to
<tt>number</tt>  bytes. If  there  are more  than <tt>number</tt>  bytes
available in  the datagram,  the remaining are  discarded. If  there are
less then <tt>number</tt>  bytes available in the  current datagram, the
available bytes are returned. If <tt>number</tt> is omitted, the maximum
datagram  size  is  used.  In case  of  timeout,  the  function  returns
<tt>nil</tt>  followed by  the  string '<tt>timeout</tt>'.  In case  the
transmission failed,  the function returns <tt>nil</tt>  followed by the
string '<tt>refused</tt>'.<p>

<a name=udpreceivefrom><tt><b>receivefrom(</b>socket [, number]<b>)</b></tt><p>

Works exactly  as the <tt>receive</tt>  function, except it  returns the
sender  <tt>ip</tt>  and  <tt>port</tt>   as  extra  return  values  and
is therefore slightly less efficient. <p>

<a name=udpselect><tt><b>select(</b>receive, send [, timeout]<b>)</b></tt><p>

Waits for  a number of sockets  to change status. <tt>Receive</tt>  is a
table with the sockets to test  for characters available for reading. OK
Sockets  in the  <tt>send</tt> table  are watched  to  see if  it is  to
immediately write  on them.  <tt>Timeout</tt> is  the maximum  amount of
time  (in seconds)  to  wait for  a change  in  status. A  <tt>nil</tt>,
negative or omitted <tt>timeout</tt> value  allows the function to block
indefinitely.  <tt>Receive</tt>  and  <tt>send</tt> can  also  be  empty
tables or <tt>nil</tt>. Non-socket values in the tables will be silently
ignored (that way you can have a handy field named <tt>"n"</tt>). <p>

The function returns a table with the sockets ready for reading, a table
with  the sockets  ready for  writing and  an error  message. The  error
message is  "timeout" if  a timeout condition  was met  and <tt>nil</tt>
otherwise. <p>

<a name=udpsend><tt><b>send(</b>socket, string<b>)</b></tt><p>

Sends <tt>string</tt>  to the  UDP peer  of socket  <tt>socket</tt>. The
method <tt>setpeername</tt> MUST have been called on <tt>socket</tt>. If
successful, the function  returns <tt>nil</tt>. In case  of timeout, the
function returns the string '<tt>timeout</tt>'. In case the transmission
failed, the function returns the string '<tt>refused</tt>'.<p>

<a name=udpsendto><tt><b>sendto(</b>socket, string, ip, port<b>)</b></tt><p>

Sends  <tt>string</tt>  to  (<tt>ip</tt>,  <tt>port</tt>).  In  case  of
timeout, the function returns the string '<tt>timeout</tt>'. <tt>Ip</tt>
MUST be an IP address, for performance reasons. In case the transmission
failed, the function returns the string '<tt>refused</tt>'.<p>

<a name=udpsetpeername><tt><b>setpeername(</b>socket, address, port<b>)</b></tt><p>

Sets the <tt>socket</tt> UDP  peer to (<tt>address</tt>, <tt>port</tt>).
<tt>Address</tt> can be  an IP address or  a host name. After  a call to
<tt>setpeername</tt>,  the <tt>send</tt>  and  <tt>receive</tt> MUST  be
used  instead  of  <tt>sendto</tt>  and  <tt>receivefrom</tt>.  Outgoing
datagrams will  be sent  to the specified  peer, and  datagrams received
from other peers will  be discarded by the OS. Since  the address of the
peer does  not have to be  passed to and  from the OS, this  practice is
recommended when the same peer is used for several transmissions and can
lead to up to 30% performance gains. <p>

<a name=udpsetsockname><tt><b>setsockname(</b>socket, address, port<b>)</b></tt><p>

Binds   the   UDP  socket   to   a   local  address   (<tt>address</tt>,
<tt>port</tt>). <tt>Address</tt> can be an IP address or a host name. If
<tt>address</tt>  is   '<tt>*</tt>'  the  system  binds   to  all  local
interfaces  (<tt>INADDR_ANY</tt>). If  <tt>port</tt>  is  0, the  system
chooses  an   ephemeral  port.  If  successful,   the  function  returns
<tt>nil</tt>. In case  of error, the function returns  an error message.
<p>

<a name=udptimeout><tt><b>timeout(</b>socket, value<b>)</b></tt><p>

Changes the  timeout value for  the socket <tt>socket</tt>.  By default,
all  operations are  blocking. The  <tt>timeout</tt> function  defines a
limit on  the amount of time  the functions can block,  specified as the
<tt>value</tt> parameter, in seconds. A <tt>nil</tt> or negative timeout
<tt>value</tt> allows operations to block indefinitely. <p>

Note:  there is  no send  buffer on  an  UDP socket.  Therefore, a  send
operation on an UDP socket should never block, regardless of the timeout
<tt>value</tt>. Receive operations, however,  can block the application.
<p>

<a name=udpsocket><tt><b>udpsocket(</b>[options]<b>)</b></tt><p>

Creates  and  returns  an  UDP  socket  object,  on  which  the  methods
<tt>close</tt>,        <tt>getpeername</tt>,       <tt>getsockname</tt>,
<tt>receive</tt>, <tt>receivefrom</tt>,  <tt>send</tt>, <tt>sendto</tt>,
<tt>setpeername</tt>, <tt>setsockname</tt>  and <tt>timeout</tt>  can be
used. In case  of error, the function returns <tt>nil</tt>  and an error
message. <p>

The table  <tt>options</tt> allows  users to specify  non-default socket
options at socket creation time. The table must be in the format:

<blockquote>
<pre>
options = {
  ["option-1-name"] = value-1,
  ["option-2-name"] = value-2,
  ["option-3-name"] = value-3,
         ...            ...
  ["option-n-name"] = value-n
}
</pre>
</blockquote>

The supported options and their expected value types are: <p>

<ul>
<li> <tt>SO_KEEPALIVE</tt>: a <i>number</i>
<li> <tt>SO_DONTROUTE</tt>: a <i>number</i>
<li> <tt>SO_BROADCAST</tt>: a <i>number</i>
<li> <tt>SO_LINGER</tt>: a <i>table</i> in the format
    <tt>{l_onoff = </tt><i>number</i>, 
    <tt>l_linger = </tt><i>number</i><tt>}</tt>.
</ul>

Note: UDP socket options should only be used by advanced users.

<h3> <a name=dnsman> DNS Services </h3> <p>

The following functions can be used to convert between host names and IP
addresses. All information returned by the resolver is returned by these
functions, as a table in the form:

<blockquote>
<pre>
resolved = {
  ["name"] = "canonic-name",
  ["alias"] = alias-list,
  ["ip"] = ip-address-list
}
</pre>
</blockquote>

Note that the <tt>alias</tt> list can be empty.

<p>

<a name=tohostname><tt><b>tohostname(</b>address<b>)</b></tt><p>

Returns a string  with the canonic host name  of given <tt>address</tt>,
followed  by a  table with  all  information returned  by the  resolver.
<tt>Address</tt> can  be an IP address  or host name. In  case of error,
the function returns <tt>nil</tt> followed by an error message. <p>

<a name=toip><tt><b>toip(</b>address<b>)</b></tt><p>

Returns a string  with the first IP address  found for <tt>address</tt>,
followed  by a  table with  all  information returned  by the  resolver.
<tt>Address</tt> can  be an IP address  or host name. In  case of error,
the function returns <tt>nil</tt> followed by an error message. <p>

<h2> <a name=proto> Protocol Reference </h2> <p>

Besides  IPv4  transport layer  support,  the  LuaSocket toolkit  offers
straightforward  support  for the  HTTP,  SMTP  and FTP  protocols.  The
support is implemented in the Lua  language and is distributed in source
code as three separate modules.

<h3> <a name=smtp> SMTP </h3> <p>

The  module  <tt>smtp.lua</tt>  provides functionality  to  send  e-mail
messages to a SMTP mail server. The implementation conforms to
<a href="http://www.tecgraf.puc-rio.br/~diego/rfc/rfc0821.txt">RFC 821</a>.<p>

MIME Headers are represented as a table in the form:<p>

<blockquote>
<pre>
headers = {
  ["field-1-name"] = "field-1-value",
  ["field-2-name"] = "field-2-value",
  ["field-3-name"] = "field-3-value",
         ...               ...
  ["field-n-name"] = "field-n-value"
}
</pre>
</blockquote>

The module exports two functions: <p>

<a name=smtp_mail><tt><b>smtp_mail(</b>from, rcpt, headers, body,
server<b>)</b></tt><p>

Sends a message to recipient list <tt>rcpt</tt>, a lua table. The sender
is given by the e-mail address <tt>from</tt>. The message is composed by
the optional  MIME Headers <tt>headers</tt> and  text <tt>body</tt>. The
message is  sent using  the server  <tt>server</tt>. If  successful, the
function returns  <tt>nil</tt>, otherwise an error  message is returned.
<p>

Examples: <br>

<blockquote>
<pre>
headers = {
  to = "fulano@tecgraf.puc-rio.br, beltrano@tecgraf.puc-rio.br",
  subject = "LuaSocket test message"
}
from = "luasocket@tecgraf.puc-rio.br"
rcpt = {
  "fulano@tecgraf.puc-rio.br",
  "beltrano@tecgraf.puc-rio.br",
  "sicrano@tecgraf.puc-rio.br"
}
body = "This is a test message. Please ignore."
server = "local"
-- connects to server "local" and sends a message to users 
-- "fulano@tecgraf.puc-rio.br" and "beltrano@tecgraf.puc-rio.br"
-- "sicrano@tecgraf.puc-rio.br" receives a 'blind carbon copy' of the message.
e = smtp_mail(from, rcpt, headers, body, server)

</pre>
</blockquote>

<a name=mail><tt><b>mail {</b><br>
&nbsp;&nbsp;to=<i>tolist</i>,<br>
&nbsp;&nbsp;from=<i>from</i>,<br>
&nbsp;&nbsp;subject=<i>subject</i>,<br>
&nbsp;&nbsp;message=<i>message</i>,<br>
&nbsp;&nbsp;cc=<i>cclist</i>,<br>
&nbsp;&nbsp;bcc=<i>bcclist</i>,<br>
&nbsp;&nbsp;mailserver=<i>server</i><br>
<b>}</b></tt><p>

The <tt>mail</tt> function, for compatibility, implements the same interface
as that of <a href="http://www.tecgraf.puc-rio.br/cgilua">CGILua 3.2</a>, 
except the <tt>mailserver</tt> parameter is mandatory.<p>

<blockquote>
<table>
<tr><td><i>to</i>:</td><td>A comma-separated list of the e-mails of 
    the recipients of the message.</td> </tr>
<tr><td><i>from</i>:</td><td>The email of the sender.</td></tr>
<tr><td><i>subject</i>:</td><td> Optional message subject.</td></tr>
<tr><td><i>message</i>:</td><td> Optional message body. </td></tr>
<tr><td><i>cc</i>:</td><td> An optional comma-separated list of the 
    e-mails of "carbon-copy" recipients. </td></tr>
<tr><td><i>bcc</i>:</td><td> An optional comma-separated list of the 
    e-mails of the "blind carbon-copy" recipients. </td></tr>
<tr><td><i>mailserver</i>:</td><td> Address of SMTP server to be used.</td></tr>
</table>
</blockquote>
<p>

The function returns <tt>nil</tt> if  the message was sent successfully.
In case of error, an error message is returned.<p>

<h3> <a name=stream> Streaming with callbacks </h3> <p>

HTTP and FTP  transfers sometimes involve large  amounts of information.
Sometimes an application  needs to generate outgoing data  in real time,
or needs to  process incoming information as it is  being received. To
address these  problems, LuaSocket 1.3b  allows HTTP message  bodies and
FTP file contents can be received or sent through the callback mechanism
outlined below. <p>

Instead of  returning the whole contents  of a FTP file  or HTTP message
body as  string to the Lua  application, the library allows  the user to
provide a  <i>receive callback</i> that  will be called  with successive
chunks of data, as the data becomes available: <p>

<blockquote>
<a name=receive_cb><tt><b>receive_cb(</b>chunk, err<b>)</b></tt><p>

The  callback provided  by the  user will  be repeatedly  called by  the
library whenever  new data  is available.  Each time  it is  called, the
callback receives  successive <tt>chunks</tt>  of downloaded  data. When
the transmission  is over, the function  is called with an  empty string
(i.e.&nbsp;<tt>""</tt>) as  the <tt>chunk</tt>. If an  error occurs, the
function  receives a  <tt>nil</tt> chunk  and  an error  message as  the
<tt>err</tt> argument. The callback  can abort transmission by returning
<tt>nil</tt> as its first return value. In that case, it can also return
an error  message. Any non-<tt>nil</tt>  return value proceeds  with the
transmission. <p>

Examples:
<blockquote>
<pre>
-- saves incoming file to disk, receiving chunk by chunk
local file = openfile(tmpname(), "wb")       -- open temp file for writing
local receive_cb = function(chunk, err)
    if chunk and chunk ~= "" then
        local res, err = write(%file, chunk) -- try to write to disk
        if not res then return nil, err      -- woops! abort with error message
        else return 1 end                    -- all is ok, please go on
    else closefile(%file) end                -- we are done
end

-- print throughput feedback while receiving data
local aux = { start = _time(), got = 0 }     -- auxiliar table
local receive_cb = function(chunk, err)
    local dt = _time() - %aux.start          -- elapsed time since start
    if not chunk or chunk == "" then return end
    %aux.got = %aux.got + strlen(chunk)      -- total bytes received
    if dt < 0.1 then return 1 end            -- not enough time for estimate
    local rate = %aux.got / dt               -- get download rate
    write("\r" .. format("%.2f", rate))      -- print estimate
    return 1                                 -- ready for more
end

</pre>
</blockquote>
</blockquote>

Instead  of forcing  the  Lua application  to pass  the  whole FTP  file
contents or  the HTTP request message  body as a string  to the library,
the library allows the user to  provide a <i>send callback</i> that will
be  called repeatedly  to  return successive  parts  of the  information
needed by the library: <p>

<blockquote>
<a name=send_cb><tt><b>send_cb()</b></tt><p>

The callback provided by the user will be repeatedly called whenever the
library needs more data to be sent. Each time the callback is called, it
should return the next part of the information the library is expecting,
followed by the total number of bytes to be sent. The callback can abort
the  process  at any  time  by  returning  <tt>nil</tt> followed  by  an
optional error message. <p>

Obs: The need for the second return value comes from the fact that, with
the HTTP protocol for instance, the library needs to know in advance the
total number of bytes that will be sent. <p>

Examples:<p>
<blockquote>
<pre>
-- sends data from file, in blocks of 4096 bytes
local file = openfile("words", "rb")         -- open file for reading
local size = seek(file, "end")               -- get file size 
seek(file, "set")                            
local send_cb = function()
    local chunk = read(%file, 4096)          -- try to read chunk
    if not chunk then                        -- are we done?
        closefile(%file) 
        return "", %size 
    else return chunk, %size end             -- if not, send what we got
end

-- sends everything in the first call
local file = openfile("words", "rb")         -- open file for reading
local data = read(file, "*a")
closefile(file)
local send_cb = function()
    return %data, strlen(%data)              -- return everything
end

</pre>
</blockquote>
</blockquote>

<h3> <a name=http> HTTP </h3> <p>

The module  <tt>http.lua</tt> provides functionality to  download an URL
from  an  HTTP  server.  The implementation  conforms  to  the  HTTP/1.1
standard,
<a href="http://www.tecgraf.puc-rio.br/~diego/rfc/rfc2068.txt">RFC 2068</a>. 
<p>

URLs MUST conform to 
<a href="http://www.tecgraf.puc-rio.br/~diego/rfc/rfc1738.txt">RFC 1738</a>, 
that is, an URL is a string in the form: <p>

<blockquote>
<pre>[http://][&lt;user&gt;[:&lt;password&gt;]@]&lt;&gt;[:&lt;port&gt;][/&lt;path&gt;] </pre>
</blockquote>

MIME Headers are represented as a table in the form:<p>

<blockquote>
<pre>
headers = {
  ["field-1-name"] = "field-1-value",
  ["field-2-name"] = "field-2-value",
  ["field-3-name"] = "field-3-value",
         ...               ...
  ["field-n-name"] = "field-n-value"
}
</pre>
</blockquote>

Field names are case insensitive (as  specified by the standard) and all
API functions  work with  lowercase field names.  Field values  are left
unmodified.<p>

The module exports three functions: <p>

<a name=http_request><tt><b>http_request(</b>method, url [, req_hdrs, req_body, stay]<b>)</b></tt><p>

Performs the generic HTTP  request using <tt>method</tt> on <tt>url</tt>
sending  the   request  headers   <tt>req_hdrs</tt>  and   request  body
<tt>req_body</tt> in  the request  message. If successful,  the function
returns the body of the reply, a table with the response headers and the
HTTP  status returned  by the  server. In  case of  error, the  function
returns   whatever  it   managed   to   retrieve  (<tt>nil</tt>   values
representing  failure) and  an error  message describing  the error.  If
<tt>&lt;user&gt;</tt> and <tt>&lt;password&gt;</tt>  are provided in the
URL,  the  function  uses  the   Basic  Authentication  Scheme  (see  <a
href=#basic>note</a>)  to  retrieve  the   document.  The  <tt>stay</tt>
parameter, when set to anything  but <tt>nil</tt>, prevents the function
from automatically following a 301 or 302 server redirect message. <p>

<a name=http_get><tt><b>http_get(</b>url [, req_hdrs, stay]<b>)</b></tt><p>

Calls <tt>http_request</tt> with method '<tt>GET</tt>'.<p>

Examples: <br>

<blockquote>
<pre>
-- connect to server "www.tecgraf.puc-rio.br" and retrieves this manual
-- file from "~diego/luasocket/manual.html"
f, m, s, e = http_get("http://www.tecgraf.puc-rio.br/~diego/luasocket/manual.html")

-- connect to server "www.tecgraf.puc-rio.br" and tries to retrieve
-- "~diego/auth/index.html". Fails because authentication is needed.
f, m, s, e = http_get("http://www.tecgraf.puc-rio.br/~diego/auth/index.html")
-- s returns with value "401 Authentication Required"

</pre>
</blockquote>

<a  name=basic> Note:  Some URLs  are  protected by  their servers  from
anonymous download. For those URLs, the server must receive some sort of
authentication  along with  the request  or  it will  deny download  and
return status "401 Authentication Required". <p>

The  HTTP/1.1 standard  defines  two authentication  methods: the  Basic
Authentication  Scheme  and  the   Digest  Authentication  Scheme,  both
explained in detail in
<a href="http://www.tecgraf.puc-rio.br/~diego/rfc/rfc2068.txt">RFC 2068</a>.
<p>

The   Basic  Authentication   Scheme  sends   <tt>&lt;user&gt;</tt>  and
<tt>&lt;password&gt;</tt>  unencrypted to  the server  and is  therefore
considered unsafe.  Unfortunately, by  the time of  this implementation,
the wide majority of servers and browsers support the Basic Scheme only.
Therefore,   this  is   the  method   used  by   the  toolkit   whenever
authentication is required.<p>

Example:
<blockquote>
<pre>
-- connect to server "www.tecgraf.puc-rio.br" and tries to retrieve
-- "~diego/auth/index.html", using the provided name and password to
-- authenticate the request
f, m, s, e = http_get("http://diego:nehab@www.tecgraf.puc-rio.br/~diego/auth/index.html")

-- alternatively, one could fill the appropriate header and authenticate
-- the request directly. both calls are equivalent
h = {authentication = "Basic " .. base64("diego:nehab")}
f, m, s, e = http_get("http://www.tecgraf.puc-rio.br/~diego/auth/index.html", h)

</pre>
</blockquote>

<a name=http_post><tt><b>http_post(</b>url, req_body [, req_hdrs, stay]<b>)</b></tt><p>

Calls   <tt>http_request</tt>   with  method   '<tt>POST</tt>'   sending
<tt>body</tt> along with the request.<p>

<a name=http_requestindirect><tt><b>http_requestindirect(</b>method, url, resp_body_cb [, req_hdrs, req_body_cb, stay]<b>)</b></tt><p>

Same  as <tt>http_request</tt>,  except that  the HTTP  response message
body is passed  to the receive callback  <tt>resp_body_cb</tt>, chunk by
chunk,  instead of  being  returned in  a  string.  Similarly, the  HTTP
request    message   body    will   be    read   from    send   callback
<tt>req_body_cb</tt>. In  case the  request has  no body,  the parameter
<tt>req_body_cb</tt> should be passed as <tt>nil</tt>. <p>

<a name=http_getindirect><tt><b>http_getindirect(</b>url, resp_body_cb
[, req_hdrs, stay]<b>)</b></tt><p>

Calls <tt>http_requestindirect</tt> with method '<tt>GET</tt>'.<p>

<a name=http_postindirect><tt><b>http_postindirect(</b>url, resp_body_cb, 
req_body_cb [, req_hdrs, stay]<b>)</b></tt><p>

Calls <tt>http_requestindirect</tt> with  method '<tt>POST</tt>' sending
message body obtained from  the send callback <tt>req_body_cb</tt> along
with the request.<p>

<h3> <a name=ftp> FTP </h3> <p>

The module  <tt>ftp.lua</tt> provides  functions to download  and upload
files  from  and to  FTP  servers.  The  implementation conforms  to  
<a href="http://www.tecgraf.puc-rio.br/~diego/rfc/rfc0959.txt">RFC 959</a>.
<p>

URLs MUST conform to 
<a href="http://www.tecgraf.puc-rio.br/~diego/rfc/rfc1738.txt">RFC 1738</a>, 
that is, an URL is a string in the form: <p>

<blockquote>
<pre>[ftp://][&lt;user&gt;[:&lt;password&gt;]@]&lt;&gt;[:&lt;port&gt;][/&lt;path&gt;] </pre>
</blockquote>

The module exports two functions: <p>

<a name=ftp_get><tt><b>ftp_get(</b>url [, type]<b>)</b></tt><p>

Downloads  the URL  <tt>url</tt> using  transfer type  <tt>type</tt> and
returns it as a  string. <p>

The parameter <tt>type</tt> can  receive values '<tt>a</tt>' (ascii, the
default) or '<tt>b</tt>'  (binary) and determines the  transfer type. If
<tt>&lt;path&gt;</tt> ends  with a '<tt>/</tt>', a  directory listing of
<tt>&lt;path&gt;</tt> is  returned. If successful, the  function returns
the file  contents as a string.  In case of error,  the function returns
<tt>nil</tt> and an error message describing the error. <p>

If no <tt>&lt;user&gt;</tt> is provided, the function tries to log in as
'<tt>anonymous</tt>'.<p>

Examples: <br>

<blockquote>
<pre>
-- log as user "anonymous" on server "ftp.tecgraf.puc-rio.br"
-- go to directory "pub/lua" and get file "lua.tar.gz" as binary.
f, e = ftp_get("ftp://ftp.tecgraf.puc-rio.br/pub/lua/lua.tar.gz", "b")

-- log as user "anonymous" on server "ftp.tecgraf.puc-rio.br"
-- go to director "pub" and retrieve directory listing of directory "lua"
f, e = ftp_get("ftp://ftp.tecgraf.puc-rio.br/pub/lua/")

-- log as user "diego", password "nehab", on server "derain.tecgraf.puc-rio.br"
-- go to directory "tec/luasocket/html" and retrieve file "manual.html"
-- (actually, fails because of wrong password :-)
f, e = ftp_get("ftp://diego:nehab@derain.tecgraf.puc-rio.br/tec/luasocket/html/manual.html")

</pre>
</blockquote>

<a name=ftp_put><tt><b>ftp_put(</b>url, data [, type]<b>)</b></tt><p>

Stores  a  file  at  <tt>url</tt> with  contents  given  by  the  string
<tt>data</tt> and using transfer type <tt>type</tt>. <p>

The parameter <tt>type</tt> can  receive values '<tt>a</tt>' (ascii, the
default) or '<tt>b</tt>'  (binary) and determines the  transfer type. If
successful, the  function returns  <tt>nil</tt>. In  case of  error, the
function returns a string describing the error.<p>

If no <tt>&lt;user&gt;</tt> is provided, the function tries to log in as
anonymous.<p>

Examples: <br>

<blockquote>
<pre>
-- log as user "anonymous" on server "ftp.free.org" and store file
-- "hello" with contents "hello world!" on current directory
e = ftp_put("ftp://ftp.free.org/hello", "hello world!")

</pre>
</blockquote>

<a name=ftp_getindirect><tt><b>ftp_getindirect(</b>url, receive_cb [, type]<b>)</b></tt><p>

Same  as <tt>ftp_get</tt>,  but  the file  contents  are  passed to  the
receive callback  <tt>receive_cb</tt> chunk  by chunk, instead  of being
returned as a string. <p>

<a name=ftp_putindirect><tt><b>ftp_putindirect(</b>url, send_cb [, type]<b>)</b></tt><p>

Same as  <tt>ftp_put</tt>, but the file  contents will be read  from the
user provided send callback <tt>send_cb</tt>, chunk by chunk.<p>

<p>
<center>
<a href=#whatis>what is</a> &middot;
<a href=#intro>introduction</a> &middot;
<a href=#current>current version</a> &middot;
<a href=#refman>functions</a> &middot;
<a href=#proto>protocols</a> 
</center>
<p>

<hr>
<table align=center>
<tr> 
<td align=center> <img alt="Created with Vim" src="vim.png">
<td align=center> and
<td align=center> <img alt="Best Viewed on Any Browser" src="anybrowser.png">
<tr> <td colspan=3 align=center>
<small>
Last modified by Diego Nehab on <br>
Wed Jun  6 19:15:34 EST 2001
</small>
</table>

</body>
</html>
