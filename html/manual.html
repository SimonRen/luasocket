<html>

<head>
<style type="text/css">
ul { list-style-type: disc };
</style>
</head>

<body bgcolor="#FFFFFF">

<hr>

<center>
<table border=0 cellspacing=0 cellpadding=0>
<tr><td align=center><img alt="The Lua language" src="lua.png">
<tr><td align=center><big><b>LuaSocket</b></big>
<tr><td align=center valign=top>IPv4 Socket support for the Lua language
</table>
</center>

<p>

<center>
<a href=#whatis>what is</a> &middot;
<a href=#intro>introduction</a> &middot;
<a href=#current>current version</a> &middot;
<a href=#refman>functions</a> &middot;
<a href=#proto>protocols</a> 
</center>

<p>

<hr>

<h2> Contents </h2><p>

<ul>
<li> <a href=#whatis>What is LuaSocket</a> 
<li> <a href=#intro>Introduction</a>
		<ul>
		<li><a href=#init>Initializing the library</a>
		<li><a href=#prog>Network programming with LuaSocket</a>
			<ul>
			<li> <a href=#TCPprog>TCP programming</a>
			<li> <a href=#UDPprog>UDP programming</a>
			</ul>
		</ul>
<li> <a href=#current>Current Version</a>
		<ul>
		<li><a href=#new>What's New</a>
		<li><a href=#incompat>Incompatibilities with Previous Versions</a>
		<li><a href=#down>Download</a>
		</ul>
<li> <a href=#refman>Function Reference</a>
	<ul>
	<li> <a href=#tcpman>TCP sockets</a>
		<ul>
		<li> <a href=#tcpaccept>accept</a>
		<li> <a href=#tcpbind>bind</a>
		<li> <a href=#tcpclose>close</a>
		<li> <a href=#tcpconnect>connect</a>
		<li> <a href=#tcpgetpeername>getpeername</a>
		<li> <a href=#tcpgetsockname>getsockname</a>
		<li> <a href=#tcpreceive>receive</a>
		<li> <a href=#tcpselect>select</a>
		<li> <a href=#tcpsend>send</a>
		<li> <a href=#tcptimeout>timeout</a>
		</ul>
	<li> <a href=#udpman>UDP sockets</a>
		<ul>
		<li> <a href=#udpclose>close</a>
		<li> <a href=#udpgetpeername>getpeername</a>
		<li> <a href=#udpgetsockname>getsockname</a>
		<li> <a href=#udpreceive>receive</a>
		<li> <a href=#udpreceivefrom>receivefrom</a>
		<li> <a href=#udpselect>select</a>
		<li> <a href=#udpsend>send</a>
		<li> <a href=#udpsendto>sendto</a>
		<li> <a href=#udpsetpeername>setpeername</a>
		<li> <a href=#udpsetsockname>setsockname</a>
		<li> <a href=#udptimeout>timeout</a>
		<li> <a href=#udpsocket>udpsocket</a>
		</ul>
	<li> <a href=#dnsman>DNS services</a>
		<ul>
		<li> <a href=#toip>toip</a>
		<li> <a href=#toip>tohostname</a>
		</ul>
	</ul>
<li> <a href=#proto>Protocol Reference</a>
	<ul>
	<li> <a href=#smtp>SMTP</a>
		<ul>
		<li> <a href=#smtp_mail>smtp_mail</a>
		<li> <a href=#mail>mail</a>
		</ul>
	<li> <a href=#http>HTTP</a>
		<ul>
		<li> <a href=#http_request>http_request</a>
		<li> <a href=#http_get>http_get</a>
		<li> <a href=#http_post>http_post</a>
		</ul>
	<li> <a href=#ftp>FTP</a>
		<ul>
		<li> <a href=#ftp_get>ftp_get</a>
		<li> <a href=#ftp_put>ftp_put</a>
		</ul>
	</ul>
</ul>
<br>

<h2> <a name=whatis> What is LuaSocket? </h2><p>

LuaSocket   is  a   <a  href="http://www.tecgraf.puc-rio.br/lua">Lua</a>
extension library  that provides  support for TCP  and UDP  socket layer
within  the Lua  language. The  library also  provides support  for SMTP
(sending  e-mails),  HTTP  (www)  and  FTP  (uploading  and  downloading
files).<p>

It  can be  used  by  any Lua  application  desiring  access to  network
communication on the Internet, once it has been properly linked with and
initialized by the interpreter running the Lua application. The code has
been tested and runs well both on Windows and on Unix platforms.<p>

The library is available under the same  terms as the Lua language, that
is, it can be used at no cost for both academic and commercial purposes.
<p>

Copyright (C) 2000 TeCGraf, PUC-Rio. All rights reserved. <br>
Author: Diego Nehab <p>

<h2> <a name=intro> Introduction </h2><p>

Below is a little introduction on how  to get the library up and running
with your applications and a  little introduction on network programming
with LuaSocket.

<h3> <a name=init> Initializing the library </h3><p>

To  have the  library  functions made  available to  a  Lua script,  the
interpreter running the script must  be linked to the <tt>luasocket</tt>
library, and  to whatever libraries  the OS  in use requires  for socket
programming. The functions are registered in  the Lua state given as the
parameter  to  the  function   <tt>lua_socketlibopen</tt>,  the  only  C
function  exported  by  the  library.  The  scripts  can  then  use  all
registered functions. <p>

<h3> <a name=prog> Network programming with LuaSocket </h3><p>

The network support  in the Lua language could closely  mirror the C API
or  could implement  a  new, independent,  transport layer  abstraction.
Having an API  similar to the C  API would make things  easier for those
who are used to socket programming. On the other hand, the simplicity of
the Lua language  would be lost. We ended up  with something in between.
<p>

One of the major differences int the API is the timeout control provided
by the  library. All I/O  operations are  blocking by default.  In other
words, the <tt>send</tt>, <tt>receive</tt> and <tt>accept</tt> functions
will block the  caller application until the operation  is completed (if
ever). The application can, however, specify upper limits on the time it
can be  blocked by  LuaSocket ("<tt>return</tt>"  timeout), on  the time
LuaSocket can  be blocked  by the OS  ("<tt>blocked</tt>" timeout)  or a
combination  of the  two.  Remember that  each  LuaSocket call  performs
several  OS  calls,  so  that the  two  timeout  values  are  <i>not</i>
equivalent. <p>

Another major difference is the receive pattern capability. Applications
can read  data from a  TCP client socket line  by line, chunk  by chunk,
until the connection  is closed etc. All I/O reads  are buffered and the
performance difference between different receive patterns is negligible.
<p>

Finally, most functions accept both IP addresses and host names. In case
a host  name is  given, the  library queries  the system's  resolver and
tries  all returned  IP addresses  until one  succeeds or  all fail.  IP
addresses are  directly encoded  and are  therefore more  efficient. The
<tt>toip</tt> and <tt>tohostname</tt> functions  are provided to convert
between host names and IP addresses. <p>

Socket objects are represented as  tables in the Lua language. Different
socket types accept different operations. These operations are available
both as stand-alone global functions and  as table methods of the socket
objects    (i.e.    the    calls   <tt>send(sock,    "test")</tt>    and
<tt>sock:send("test")</tt>  are  equivalent). It  is  considered  better
style  to  use  the  table method  versions,  which  are  sligthly  more
efficient. <p>

<a name=TCPprog><b>TCP programming</b><p>

TCP is a reliable stream protocol. In other words, applications send and
receive data as an error free stream of  bytes. Data is split in one end
and reassembled transparently on the  other end. There are no boundaries
in  the data  transfers.  The library  allows users  to  read data  with
several different  granurality from the sockets:  patterns are available
for  words, lines,  arbitrary sized  blocks  or "read  up to  connection
closed", all with similar performance. <p>

The library distinguishes  two types of TCP sockets:  client sockets and
server sockets. <p>

Client sockets are  used to exchange data between  two applications over
the Internet. Client sockets are  created by the <tt>connect</tt> global
function  or  returned  by  the <tt>accept</tt>  server  socket  method.
Applications can call the  methods <tt>send</tt> and <tt>receive</tt> to
send and  receive data.  The other methods  available for  client socket
objects are <tt>getsockname</tt>, <tt>getpeername</tt>, <tt>timeout</tt>
and <tt>close</tt>.<p>

Server sockets are created by  the <tt>bind</tt> global function and are
associated with a  address and port on the local  host. Applications use
the <tt>accept</tt> server socket method to wait for a client connection
on a  server socket. Once a  connection is established, a  client socket
object  is  returned representing  this  connection.  The other  methods
available   for   server   socket  objects   are   <tt>getsockname</tt>,
<tt>timeout</tt> and <tt>close</tt>. <p>

<a name=UDPprog><b>UDP programming</b><p>

UDP is  a non-reliable datagram  protocol. In other  words, applications
send and receive data as independent blocks, which are not guaranteed to
reach the other  end. Even when they  reach the other end,  they are not
guaranteed to be error free. Data  transfers are atomic, one datagram at
a time. Reading only  part of a datagram discards the  rest, so that the
next read operation will act on the next datagram. The advantages are in
simplicity (no connection  setup) and performance (no  error checking or
correction). <p>

An UDP socket object is  created by the <tt>udpcreate</tt> function. UDP
sockets  do   not  need   to  be  connected   before  use.   The  method
<tt>sendto</tt>  can  be  used  immediately after  creation  to  send  a
datagram to  any UDP  (ip, port)  pair. Host names  are not  allowed for
performance reasons.  Methods <tt>receive</tt>  and <tt>receivefrom</tt>
can be used to retrieve datagrams, the  latter returning the ip and port
of  the sender  as  extra return  values (what  makes  it slightly  less
efficient). <p>

When  communication  is performed  repeatedly  with  a single  peer,  an
application  should call  the <tt>setpeername</tt>  method to  specify a
permanent partner.  The method  <tt>send</tt> can then  be used  to send
data   directly  to   the   peer,  and   methods  <tt>receive</tt>   and
<tt>receivefrom</tt> will  only return  datagrams originating  from that
peer. There is about 30% performance gain due to this practice. <p>

To associate  an UDP socket with  a local address, an  application calls
the   <tt>setsockname</tt>   function.   Otherwise,    the   socket   is
automatically  bound  to an  ephemeral  address  before the  first  data
transmission.  The   other  methods   available  for  UDP   sockets  are
<tt>getpeername</tt>,    <tt>getsockname</tt>,   <tt>timeout</tt>    and
<tt>close</tt>. <p>

<h2> <a name=current>Current Version</h2><p>

LuaSocket version 1.2.1 is now  available for download! It is compatible
with   Lua&nbsp;4.0   and   has    been   tested   on   Windows&nbsp;98,
Windows&nbsp;2000, Linux, AIX, SunOS  and IRIX. <p>

<h3><a name=new>What's New</h3><p>

The  major  improvement  in  version   1.2.1  is  the  addition  of  the
<tt>select</tt> function,  that allows  the user  to wait  for a  set of
sockets to change status. Here are the most important changes:

<ul>
<li> Added <tt>select</tt> support. It should be easy to implement 
     servers with LuaSocket 1.2.1.
<li> Simplified treatment of global methods. The ~300 lines of code were 
     replaced by ~15 that do the same job in a faster and cleaner way.
<li> Added '<tt>*w</tt>' receive pattern to increase compatibility
     with Lua's <tt>read</tt> function.
<li> <tt>close</tt> is now allowed on previously closed sockets.
<li> Removed the <tt>poll</tt> method. It was replaced with advantage 
     by the <tt>select</tt> method.
</ul>

<h3><a name=incompat>Incompatibilities with Previous Versions</h3><p>

The  <tt>poll</tt>   function  has  been  replaced   with  advantage  by
<tt>select</tt> and is no longer supported.

<h3><a name=down> Download </h3><p>

The library can be downloaded in source code from the following links: <p>

<a href="luasocket-1.2.1.tar.gz">luasocket-1.2.1.tar.gz</a> <br>
<a href="luasocket-1.2.1.zip">luasocket-1.2.1.zip</a> <p>

<h2> <a name=refman> Function Reference </h2> <p>

All the functions  of the API are described below.  Several examples are
given in  the distribution, including  the automated tests and  the full
implementation of the protocols FTP, SMTP and HTTP. <p>

Note that although some function  names are overloaded, documentation is
provided separately for TCP and UDP sockets. <p>

<h3> <a name=tcpman> TCP sockets </h3> <p>

<a name=tcpaccept><tt><b>accept(</b>socket<b>)</b></tt><p>

Creates and  returns a TCP  client socket object, representing  a client
attempting connection on the server <tt>socket</tt>. The function blocks
until  a remote  connection attempt  is  detected or  until the  timeout
condition is met. <p>

<a name=tcpbind><tt><b>bind(</b>address, port [, backlog]<b>)</b></tt><p>

Creates  a new  TCP server  socket  and binds  it to  (<tt>address</tt>,
<tt>port</tt>) on the local host.  <tt>Address</tt> can be an IP address
or a host name. If <tt>address</tt> is '<tt>*</tt>', the system binds to
all local  interfaces (<tt>INADDR_ANY</tt>). If <tt>port</tt>  is 0, the
system automatically  chooses an ephemeral port.  The optional parameter
<tt>backlog</tt>  (default  value  1)  specifies the  number  of  client
connections that can be queued waiting for service. If the queue is full
and another  client attempts connection,  the connection is  refused. In
case of  success, the  function returns  a server  socket, on  which the
operations  <tt>accept</tt>,  <tt>close</tt>,  <tt>getsockname</tt>  and
<tt>listen</tt> are  permitted. In case  of error, the  function returns
<tt>nil</tt> followed by a string describing the error. <p>

<a name=tcpclose><tt><b>close(</b>socket<b>)</b></tt><p>

Closes the socket <tt>socket</tt>. No  further operations are allowed on
a  closed  socket. The  local  address  to which  it  is  bound is  made
available  to other  applications. <p>

Note:  It is  important to  close all  used  sockets once  they are  not
needed,  since, in  many systems,  each socket  uses a  file descriptor,
which are a limited system resource. <p>

<a name=tcpconnect><tt><b>connect(</b>address, port<b>)</b></tt><p>

Creates   a  new   TCP   client   socket  and   tries   to  connect   to
(<tt>address</tt>, <tt>port</tt>). <tt>Address</tt> can be an IP address
or a host name. In case of success, the function returns a client socket
on   which   the   operations    <tt>send</tt>,   <tt>receive</tt>   and
<tt>close</tt> are  permitted. In  case of  error, the  function returns
<tt>nil</tt> followed by a string describing the error. <p>

<a name=tcpgetpeername><tt><b>getpeername(</b>socket<b>)</b></tt><p>

Returns the IP address and port of  the peer connected to the TCP client
<tt>socket</tt> or <tt>nil</tt> in case of  error. Note that it makes no
sense to call <tt>getpeername</tt> on a server socket object. <p>

<a name=tcpgetsockname><tt><b>getsockname(</b>socket<b>)</b></tt><p>

Returns the local IP address and port of the TCP <tt>socket</tt>
or <tt>nil</tt> in case of error. <p>

<a name=tcpreceive><tt><b>receive(</b>socket [, pattern<sub>1</sub></tt>, <tt>pattern</tt><sub>2</sub>, ... <tt>pattern</tt><sub>N</sub>]<b><tt>)</tt></b><p>

Receives <tt>pattern</tt><sub>1</sub>, <tt>pattern</tt><sub>2</sub>, ...
<tt>pattern</tt><sub>N</sub> from the  client <tt>socket</tt>. A pattern
can be one of the following:

<ul>

<li>  '<tt>*a</tt>':  reads from  the  socket  until the  connection  is
closed. No end-of-line translation is performed;

<li> '<tt>*l</tt>':  reads a line of  text from the socket.  The line is
terminated by a  LF character (ASCII&nbsp;10), optionally  preceded by a
CR character (ASCII&nbsp;13). The CR and LF characters are not returned.
This is the default pattern;

<li> '<tt>*lu</tt>': reads  a line of text from the  socket. The line is
assumed to be  terminated by a single LF character.  If the LF character
is is preceded  by a CR character,  the CR character is  returned in the
string, whereas the LF character is not;

<li> '<tt>*w</tt>':  reads a word (maximal  sequence of non-white-space
characters), skipping spaces if necessary;

<li> <tt>number</tt>:  causes the  function to read  <tt>number</tt> raw
bytes from the socket. 

</ul>

The function returns  one value for each pattern, followed  by a single
error  code that  can be  <tt>nil</tt> in  case of  success, the  string
'<tt>closed</tt>'  in   case  the  connection  was   closed  before  the
transmission was complete or the string '<tt>timeout</tt>' in case there
was  a  timeout during  the  operation.  The difference  in  performance
between all patterns is negligible. <p>

<a name=tcpselect><tt><b>select(</b>receive, send [, timeout]<b>)</b></tt><p>

Waits for  a number of sockets  to change status. <tt>Receive</tt>  is a
table with  the sockets  to test for  characters available  for reading.
Sockets in  the <tt>send</tt> table  are watched to see  if it is  ok to
immediately write  on them.  <tt>Timeout</tt> is  the maximum  amount of
time  (in seconds)  to  wait for  a change  in  status. A  <tt>nil</tt>,
negative or omitted <tt>timeout</tt> value  allows the function to block
indefinitely.  <tt>Receive</tt>  and  <tt>send</tt> can  also  be  empty
tables or <tt>nil</tt>. Non-socket values in the tables will be silently
ignored (that way you can have a handy field named <tt>"n"</tt>). <p>

The function returns a table with the sockets ready for reading, a table
with  the sockets  ready for  writing and  an error  message. The  error
message is  "timeout" if  a timeout condition  was met  and <tt>nil</tt>
otherwise. <p>

Important Note:  a known  bug in  WinSock prevents  <tt>select</tt> from
working properly on non-blocking TCP  sockets. The function may return a
socket as <i>writable</i> even though the socket is <i>not</i> ready for
sending. <p>

Note:   calling   <tt>select</tt>   with   a  server   socket   in   the
<tt>receive</tt>  parameter  before  a   call  to  <tt>accept</tt>  does
<i>not</i> guarantee  <tt>accept</tt> will  return immediately.  Use the
<tt>timeout</tt>  server socket  method or  <tt>accept</tt> <i>might</i>
block forever. <p>

Examples:

<blockquote>
<pre>
-- waits for input on three sockets and broadcasts any received lines
server = bind("localhost", 8080)
a = server:accept(); b = server:accept(); c = server:accept()
a:timeout(1); b:timeout(1); c:timeout(1)
while 1 do
  r, _, e = select({a,b,c}, nil)
  for i,v in r do
    l, e = v:receive()
    if e then exit() end
    _, s, e = select(nil, {a,b,c}, 1)
    for j,u in s do
      e = u:send(l, "\n") 
      if e then exit() end
    end
  end
end

</pre>
</blockquote>

<a name=tcpsend><tt><b>send(</b>socket, string<sub>1</sub> </tt>[, <tt>string</tt><sub>2</sub>, ... <tt>string</tt><sub>N</sub>]<b><tt>)</tt></b><p>

Sends the strings <tt>string</tt><sub>1</sub>, 
<tt>string</tt><sub>2</sub>, ... <tt>string</tt><sub>N</sub> through the
client socket <tt>socket</tt>. The function returns an error code, which
is <tt>nil</tt> in case of success, the string '<tt>closed</tt>' in case
the connection  was closed before  the transmission was complete  or the
string  '<tt>timeout</tt>'  in  case  there was  a  timeout  during  the
operation.  After the  error code,  the function  returns the  number of
bytes accepted by the transport layer. <p>

<a name=tcptimeout><tt><b>timeout(</b>socket, value [, mode]<b>)</b></tt><p>

Changes the timeout  values for the socket  <tt>socket</tt>. By default,
all I/O  operations are  blocking. That  is, any  call to  the functions
<tt>send</tt> and  <tt>receive</tt> will  block indefinitely,  until the
operation completes.  The <tt>timeout</tt>  function defines a  limit on
the  amount  of   time  the  functions  can  block,   specified  as  the
<tt>value</tt> parameter,  in seconds. There  are two timeout  modes and
both can be used together for fine tuning:

<ul>
<li> '<tt>b</tt>': <i>blocked</i> timeout.  Specifies the upper limit on
the amount  of time  LuaSocket can  be blocked  by the  operating system
while waiting for completion of any single I/O operation;</li>

<li> '<tt>r</tt>':  <i>return</i> timeout. Specifies the  upper limit on
the amount of  time LuaSocket can block a Lua  script before returning a
function call.</li> </ul>

The  <tt>nil</tt>  timeout  <tt>value</tt> allows  operations  to  block
indefinitely. Negative timeout values have the same effect. <p>

Note: although timeout values have millisecond precision, large blocks can
cause I/O functions not to respect timeout values due to the time the
library takes to transfer blocks to and from the kernel and to and from the
Lua interpreter. <p>

<h3> <a name=udpman> UDP sockets </h3> <p>

<a name=udpclose><tt><b>close(</b>socket<b>)</b></tt><p>

Closes the socket <tt>socket</tt>. No  further operations are allowed on
a  closed  socket. The  local  address  to which  it  is  bound is  made
available to other applications. <p>

Note:  It is  important to  close all  used  sockets once  they are  not
needed,  since, in  many systems,  each socket  uses a  file descriptor,
which are a limited system resource. <p>

<a name=udpgetpeername><tt><b>getpeername(</b>socket<b>)</b></tt><p>

Returns the IP address and port of the peer of the UDP <tt>socket</tt>.
The function will fail unless a peer has been set with a call to
<tt>setpeername</tt>. <p>

<a name=udpgetsockname><tt><b>getsockname(</b>socket<b>)</b></tt><p>

Returns the local IP address and port of the TCP <tt>socket</tt>
or <tt>nil</tt> in case of error. <p>

Note:   UDP   sockets    are   not   bound   to    any   address   until
<tt>setsockname</tt> or  the first <tt>sendto</tt> method  is called (in
which case it  is bound to an ephemeral port  and the wild-card address).
The local address will not change thereafter. <p>

<a name=udpreceive><tt><b>receive(</b>socket [, number]<b>)</b></tt><p>

Receives  a datagram  from the  UDP  socket <tt>socket</tt>  with up  to
<tt>number</tt>  bytes. If  there  are more  than <tt>number</tt>  bytes
available in  the datagram,  the remaining are  discarded. If  there are
less then <tt>number</tt>  bytes available in the  current datagram, the
available bytes are returned. If <tt>number</tt> is omitted, the maximum
datagram  size  is  used.  In case  of  timeout,  the  function  returns
<tt>nil</tt>  followed by  the  string '<tt>timeout</tt>'.  In case  the
transmission failed,  the function returns <tt>nil</tt>  followed by the
string '<tt>refused</tt>'.<p>

<a name=udpreceivefrom><tt><b>receivefrom(</b>socket [, number]<b>)</b></tt><p>

Works exactly  as the <tt>receive</tt>  function, except it  returns the
sender  <tt>ip</tt>  and  <tt>port</tt>   as  extra  return  values  and
therefore is slightly less efficient. <p>

<a name=udpselect><tt><b>select(</b>receive, send [, timeout]<b>)</b></tt><p>

Waits for  a number of sockets  to change status. <tt>Receive</tt>  is a
table with  the sockets  to test for  characters available  for reading.
Sockets in  the <tt>send</tt> table  are watched to see  if it is  ok to
immediately write  on them.  <tt>Timeout</tt> is  the maximum  amount of
time  (in seconds)  to  wait for  a change  in  status. A  <tt>nil</tt>,
negative or omitted <tt>timeout</tt> value  allows the function to block
indefinitely.  <tt>Receive</tt>  and  <tt>send</tt> can  also  be  empty
tables or <tt>nil</tt>. Non-socket values in the tables will be silently
ignored (that way you can have a handy field named <tt>"n"</tt>). <p>

The function returns a table with the sockets ready for reading, a table
with  the sockets  ready for  writing and  an error  message. The  error
message is  "timeout" if  a timeout condition  was met  and <tt>nil</tt>
otherwise. <p>

<a name=udpsend><tt><b>send(</b>socket, string<b>)</b></tt><p>

Sends <tt>string</tt>  to the  UDP peer  of socket  <tt>socket</tt>. The
method <tt>setpeername</tt> MUST have been called on <tt>socket</tt>. If
successful, the function  returns <tt>nil</tt>. In case  of timeout, the
function returns the string '<tt>timeout</tt>'. In case the transmission
failed, the function returns the string '<tt>refused</tt>'.<p>

<a name=udpsendto><tt><b>sendto(</b>socket, string, ip, port<b>)</b></tt><p>

Sends  <tt>string</tt>  to  (<tt>ip</tt>,  <tt>port</tt>).  In  case  of
timeout, the function returns the string '<tt>timeout</tt>'. <tt>Ip</tt>
MUST be an IP address, for performance reasons. In case the transmission
failed, the function returns the string '<tt>refused</tt>'.<p>

<a name=udpsetpeername><tt><b>setpeername(</b>socket, address, port<b>)</b></tt><p>

Sets the <tt>socket</tt> UDP  peer to (<tt>address</tt>, <tt>port</tt>).
<tt>Address</tt> can be  an IP address or  a host name. After  a call to
<tt>setpeername</tt>,  the <tt>send</tt>  and  <tt>receive</tt> MUST  be
used  instead  of  <tt>sendto</tt>  and  <tt>receivefrom</tt>.  Outgoing
datagrams will  be sent  to the specified  peer, and  datagrams received
from other peers will  be discarded by the OS. Since  the address of the
peer does  not have to be  passed to and  from the OS, this  practice is
recommended when the same peer is used for several transmissions and can
lead to up to 30% performance gains. <p>

<a name=udpsetsockname><tt><b>setsockname(</b>socket, address, port<b>)</b></tt><p>

Binds   the   UDP  socket   to   a   local  address   (<tt>address</tt>,
<tt>port</tt>). <tt>Address</tt> can be an IP address or a host name. If
<tt>address</tt>  is   '<tt>*</tt>'  the  system  binds   to  all  local
interfaces  (<tt>INADDR_ANY</tt>). If  <tt>port</tt>  is  0, the  system
chooses  an   ephemeral  port.  If  successful,   the  function  returns
<tt>nil</tt>. In case  of error, the function returns  an error message.
<p>

<a name=udptimeout><tt><b>timeout(</b>socket, value<b>)</b></tt><p>

Changes the  timeout value for  the socket <tt>socket</tt>.  By default,
all  operations are  blocking. The  <tt>timeout</tt> function  defines a
limit on  the amount of time  the functions can block,  specified as the
<tt>value</tt>   parameter,  in   seconds.   The  <tt>nil</tt>   timeout
<tt>value</tt> allows operations to block indefinitely. Negative timeout
values have the same effect.<p>

Note:  there is  no send  buffer on  an  UDP socket.  Therefore, a  send
operation on an UDP socket should never block, regardless of the timeout
<tt>value</tt>. Receive operations, however, can block the application.
<p>

<a name=udpsocket><tt><b>udpsocket()</b></tt><p>

Creates  and  returns  an  UDP  socket  object,  on  which  the  methods
<tt>close</tt>,        <tt>getpeername</tt>,       <tt>getsockname</tt>,
<tt>receive</tt>, <tt>receivefrom</tt>,  <tt>send</tt>, <tt>sendto</tt>,
<tt>setpeername</tt>, <tt>setsockname</tt>  and <tt>timeout</tt>  can be
used. In case  of error, the function returns <tt>nil</tt>  and an error
message. <p>

<h3> <a name=dnsman> DNS Services </h3> <p>

The following functions can be used to convert between host names and IP
addresses. All information returned by the resolver is returned by these
functions, as a table in the form:

<blockquote>
<pre>
resolved = {
  ["name"] = "canonic-name",
  ["alias"] = alias-list,
  ["ip"] = ip-address-list
}
</pre>
</blockquote>

Note that the <tt>alias</tt> list can be empty.

<p>

<a name=tohostname><tt><b>tohostname(</b>address<b>)</b></tt><p>

Returns a string  with the canonic host name  of given <tt>address</tt>,
followed  by a  table with  all  information returned  by the  resolver.
<tt>Address</tt> can be  an IP address or host name.  In case of error,
the function returns <tt>nil</tt> followed by an error message. <p>

<a name=toip><tt><b>toip(</b>address<b>)</b></tt><p>

Returns a string  with the first IP address  found for <tt>address</tt>,
followed  by a  table with  all  information returned  by the  resolver.
<tt>Address</tt> can  be an IP address  or host name. In  case of error,
the function returns <tt>nil</tt> followed by an error message. <p>

<h2> <a name=proto> Protocol Reference </h2> <p>

Besides  IPv4  transport layer  support,  the  LuaSocket toolkit  offers
straightforward  support  for the  HTTP,  SMTP  and FTP  protocols.  The
support is implemented in the Lua  language and is distributed in source
code as three separate modules.

<h3> <a name=smtp> SMTP </h3> <p>

The  module  <tt>smtp.lua</tt>  provides functionality  to  send  e-mail
messages to a SMTP mail server. The implementation conforms to
<a href="http://www.tecgraf.puc-rio.br/~diego/rfc/rfc0821.txt">RFC 821</a>.<p>

MIME Headers are represented as a table in the form:<p>

<blockquote>
<pre>
headers = {
  ["field-1-name"] = "field-1-value",
  ["field-2-name"] = "field-2-value",
  ["field-3-name"] = "field-3-value",
         ...               ...
  ["field-n-name"] = "field-n-value"
}
</pre>
</blockquote>

The module exports two functions: <p>

<a name=smtp_mail><tt><b>smtp_mail(</b>from, rcpt, headers, body,
server<b>)</b></tt><p>

Sends a message to recipient list <tt>rcpt</tt>, a lua table. The sender
is given by the e-mail address <tt>from</tt>. The message is composed by
the optional  MIME Headers <tt>headers</tt> and  text <tt>body</tt>. The
message is  sent using  the server  <tt>server</tt>. If  successful, the
function returns  <tt>nil</tt>, otherwise an error  message is returned.
<p>

Examples: <br>

<blockquote>
<pre>
headers = {
  to = "fulano@tecgraf.puc-rio.br, beltrano@tecgraf.puc-rio.br",
  subject = "LuaSocket test message"
}
from = "luasocket@tecgraf.puc-rio.br"
rcpt = {
  "fulano@tecgraf.puc-rio.br",
  "beltrano@tecgraf.puc-rio.br",
  "sicrano@tecgraf.puc-rio.br"
}
body = "This is a test message. Please ignore."
server = "local"
-- connects to server "local" and sends a message to users 
-- "fulano@tecgraf.puc-rio.br" and "beltrano@tecgraf.puc-rio.br"
-- "sicrano@tecgraf.puc-rio.br" receives a 'blind carbon copy' of the message.
e = smtp_mail(from, rcpt, headers, body, server)

</pre>
</blockquote>

<a name=mail><tt><b>mail {</b><br>
&nbsp;&nbsp;to=<i>tolist</i>,<br>
&nbsp;&nbsp;from=<i>from</i>,<br>
&nbsp;&nbsp;subject=<i>subject</i>,<br>
&nbsp;&nbsp;message=<i>message</i>,<br>
&nbsp;&nbsp;cc=<i>cclist</i>,<br>
&nbsp;&nbsp;bcc=<i>bcclist</i>,<br>
&nbsp;&nbsp;mailserver=<i>server</i><br>
<b>}</b></tt><p>

The <tt>mail</tt> function, for compatibility, implements the same interface
as that of <a href="http://www.tecgraf.puc-rio.br/cgilua">CGILua 3.2</a>, 
except the <tt>mailserver</tt> parameter is mandatory.<p>

<blockquote>
<table>
<tr><td><i>to</i>:</td><td>A comma-separated list of the e-mails of 
    the recipients of the message.</td> </tr>
<tr><td><i>from</i>:</td><td>The email of the sender.</td></tr>
<tr><td><i>subject</i>:</td><td> Optional message subject.</td></tr>
<tr><td><i>message</i>:</td><td> Optional message body. </td></tr>
<tr><td><i>cc</i>:</td><td> An optional comma-separated list of the 
    e-mails of "carbon-copy" recipients. </td></tr>
<tr><td><i>bcc</i>:</td><td> An optional comma-separated list of the 
    e-mails of the "blind carbon-copy" recipients. </td></tr>
<tr><td><i>mailserver</i>:</td><td> Address of SMTP server to be used.</td></tr>
</table>
</blockquote>
<p>

The function returns <tt>nil</tt> if  the message was sent successfully.
In case of error, an error message is returned.<p>

<h3> <a name=http> HTTP </h3> <p>

The module  <tt>http.lua</tt> provides functionality to  download an URL
from  an  HTTP  server.  The implementation  conforms  to  the  HTTP/1.1
standard,
<a href="http://www.tecgraf.puc-rio.br/~diego/rfc/rfc2068.txt">RFC 2068</a>. 
<p>

URLs MUST conform to 
<a href="http://www.tecgraf.puc-rio.br/~diego/rfc/rfc1738.txt">RFC 1738</a>, 
that is, an URL is a string in the form: <p>

<blockquote>
<pre>[http://][&lt;user&gt;[:&lt;password&gt;]@]&lt;&gt;[:&lt;port&gt;][/&lt;path&gt;] </pre>
</blockquote>

MIME Headers are represented as a table in the form:<p>

<blockquote>
<pre>
headers = {
  ["field-1-name"] = "field-1-value",
  ["field-2-name"] = "field-2-value",
  ["field-3-name"] = "field-3-value",
         ...               ...
  ["field-n-name"] = "field-n-value"
}
</pre>
</blockquote>

Field names are case insensitive (as  specified by the standard) and all
API functions  work with  lowercase field names.  Field values  are left
unmodified.<p>

The module exports three functions: <p>

<a name=http_request><tt><b>http_request(</b>method, url [, headers, body]<b>)</b></tt><p>

Performs the generic HTTP  request using <tt>method</tt> on <tt>url</tt>
sending  the request  <tt>headers</tt> and  message <tt>body</tt>  along
with the  request. If successful, the  function returns the body  of the
reply, a  table with mime  headers and the  HTTP status returned  by the
server. In  case of error, the  function returns whatever it  managed to
retrieve  (<tt>nil</tt> values  representing failure)  and and  an error
message   describing    the   error.   If    <tt>&lt;user&gt;</tt>   and
<tt>&lt;password&gt;</tt> are provided in the URL, the function uses the
Basic Authentication  Scheme (see  <a href=#basic>note</a>)  to retrieve
the document. <p>

<a name=http_get><tt><b>http_get(</b>url [, headers]<b>)</b></tt><p>

Calls <tt>http_request</tt> with method '<tt>GET</tt>'.<p>

Examples: <br>

<blockquote>
<pre>
-- connect to server "www.tecgraf.puc-rio.br" and retrieves this manual
-- file from "~diego/luasocket/manual.html"
f, m, s, e = http_get("http://www.tecgraf.puc-rio.br/~diego/luasocket/manual.html")

-- connect to server "www.tecgraf.puc-rio.br" and tries to retrieve
-- "~diego/auth/index.html". Fails because authentication is needed.
f, m, s, e = http_get("http://www.tecgraf.puc-rio.br/~diego/auth/index.html")
-- s returns with value "401 Authentication Required"

</pre>
</blockquote>

<a  name=basic> Note:  Some URLs  are  protected by  their servers  from
anonymous download. For those URLs, the server must receive some sort of
authentication  along with  the request  or  it will  deny download  and
return status "401 Authentication Required". <p>

The  HTTP/1.1 standard  defines  two authentication  methods: the  Basic
Authentication  Scheme  and  the   Digest  Authentication  Scheme,  both
explained in detail in
<a href="http://www.tecgraf.puc-rio.br/~diego/rfc/rfc2068.txt">RFC 2068</a>.
<p>

The   Basic  Authentication   Scheme  sends   <tt>&lt;user&gt;</tt>  and
<tt>&lt;password&gt;</tt>  unencrypted to  the server  and is  therefore
considered unsafe.  Unfortunately, by  the time of  this implementation,
the wide majority of servers and browsers support the Basic Scheme only.
Therefore,   this  is   the  method   used  by   the  toolkit   whenever
authentication is required.<p>

Example:
<blockquote>
<pre>
-- connect to server "www.tecgraf.puc-rio.br" and tries to retrieve
-- "~diego/auth/index.html", using the provided name and password to
-- authenticate the request
f, m, s, e = http_get("http://diego:nehab@www.tecgraf.puc-rio.br/~diego/auth/index.html")

-- alternatively, one could fill the appropriate header and authenticate
-- the request directly. both calls are equivalent
h = {authentication = "Basic " .. base64("diego:nehab")}
f, m, s, e = http_get("http://www.tecgraf.puc-rio.br/~diego/auth/index.html", h)

</pre>
</blockquote>

<a name=http_post><tt><b>http_post(</b>url, body [, headers]<b>)</b></tt><p>

Calls   <tt>http_request</tt>   with  method   '<tt>POST</tt>'   sending
<tt>body</tt> along with the request.<p>

<h3> <a name=ftp> FTP </h3> <p>

The module  <tt>ftp.lua</tt> provides  functions to download  and upload
files  from  and to  FTP  servers.  The  implementation conforms  to  
<a href="http://www.tecgraf.puc-rio.br/~diego/rfc/rfc0959.txt">RFC 959</a>.
<p>

URLs MUST conform to 
<a href="http://www.tecgraf.puc-rio.br/~diego/rfc/rfc1738.txt">RFC 1738</a>, 
that is, an URL is a string in the form: <p>

<blockquote>
<pre>[ftp://][&lt;user&gt;[:&lt;password&gt;]@]&lt;&gt;[:&lt;port&gt;][/&lt;path&gt;] </pre>
</blockquote>

The module exports two functions: <p>

<a name=ftp_get><tt><b>ftp_get(</b>url [, type]<b>)</b></tt><p>

Downloads  the URL  <tt>url</tt> using  transfer type  <tt>type</tt> and
returns it as a  string. <p>

The parameter <tt>type</tt> can  receive values '<tt>a</tt>' (ascii, the
default) or '<tt>b</tt>'  (binary) and determines the  transfer type. If
<tt>&lt;path&gt;</tt> ends  with a '<tt>/</tt>', a  directory listing of
<tt>&lt;path&gt;</tt> is  returned. If successful, the  function returns
the file  contents as a string.  In case of error,  the function returns
<tt>nil</tt> and an error message describing the error. <p>

If no <tt>&lt;user&gt;</tt> is provided, the function tries to log in as
'<tt>anonymous</tt>'.<p>

Examples: <br>

<blockquote>
<pre>
-- log as user "anonymous" on server "ftp.tecgraf.puc-rio.br"
-- go to directory "pub/lua" and get file "lua.tar.gz" as binary.
f, e = ftp_get("ftp://ftp.tecgraf.puc-rio.br/pub/lua/lua.tar.gz", "b")

-- log as user "anonymous" on server "ftp.tecgraf.puc-rio.br"
-- go to director "pub" and retrieve directory listing of directory "lua"
f, e = ftp_get("ftp://ftp.tecgraf.puc-rio.br/pub/lua/")

-- log as user "diego", password "nehab", on server "derain.tecgraf.puc-rio.br"
-- go to directory "tec/luasocket/html" and retrieve file "manual.html"
-- (actually, fails because of wrong password :-)
f, e = ftp_get("ftp://diego:nehab@derain.tecgraf.puc-rio.br/tec/luasocket/html/manual.html")

</pre>
</blockquote>

<a name=ftp_put><tt><b>ftp_put(</b>url, data [, type]<b>)</b></tt><p>

Stores  a  file  at  <tt>url</tt> with  contents  given  by  the  string
<tt>data</tt> and using transfer type <tt>type</tt>. <p>

The parameter <tt>type</tt> can  receive values '<tt>a</tt>' (ascii, the
default) or '<tt>b</tt>'  (binary) and determines the  transfer type. If
successful, the  function returns  <tt>nil</tt>. In  case of  error, the
function returns a string describing the error.<p>

If no <tt>&lt;user&gt;</tt> is provided, the function tries to log in as
anonymous.<p>

Examples: <br>

<blockquote>
<pre>
-- log as user "anonymous" on server "ftp.free.org" and store file
-- "hello" with contents "hello world!" on current directory
e = ftp_put("ftp://ftp.free.org/hello", "hello world!")

</pre>
</blockquote>

<p>
<center>
<a href=#whatis>what is</a> &middot;
<a href=#intro>introduction</a> &middot;
<a href=#current>current version</a> &middot;
<a href=#refman>functions</a> &middot;
<a href=#proto>protocols</a> 
</center>
<p>

<hr>
<table align=center>
<tr> 
<td align=center> <img alt="Created with Vim" src="vim.png">
<td align=center> and
<td align=center> <img alt="Best Viewed on Any Browser" src="anybrowser.png">
<tr> <td colspan=3 align=center>
<small>
Last modified by Diego Nehab on <br>
Thu Jan 25 16:11:36 EDT 2001
</small>
</table>

</body>
</html>
