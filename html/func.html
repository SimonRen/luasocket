<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>

<head>
<title>LuaSocket: IPv4 Sockets support for the Lua language </title>
<style type="text/css">
ul { list-style-type: disc };
</style>
</head>

<body bgcolor="#FFFFFF">

<hr>

<center>
<table summary="LuaSocket logo" border=0 cellspacing=0 cellpadding=0>
<tr><td align=center>
<a href="http://www.lua.org">
<img border=0 alt="LuaSocket" src="luasocket.png">
</a>
<tr><td align=center valign=top>IPv4 Sockets support for the Lua language
</table>
</center>

<p align=center>
<a href="home.html">home</a> &middot;
<a href="home.html#down">download</a> &middot;
<a href="home.html#whatis">what is</a> &middot;
<a href="intro.html">introduction</a> &middot;
<a href="func.html">functions</a> &middot;
<a href="mod.html">modules</a> &middot;
<a href="idx.html">index</a> 
<p>

<hr>

<h2> Function Reference </h2> <p>

All the functions  of the API are described below.  Several examples are
given in  the distribution, including  the automated tests and  the full
implementation of the protocols FTP, SMTP and HTTP. <p>

Note that although some function  names are overloaded, documentation is
provided separately for TCP and UDP sockets. <p>

<h3> <a name=tcp>TCP sockets</a></h3> <p>

<a name=tcp.accept><tt><b>accept(</b>socket<b>)</b></tt></a><p>

Waits  for  a   TCP  client  to  attempt  connection   with  the  server
<tt>socket</tt>, and  returns a  client socket  object connected  to the
remote  end.  If  a  timeout condition  is  met,  the  function  returns
<tt>nil</tt> followed by the string '<tt>timeout</tt>'. <p>

<a name=tcp.bind><tt><b>bind(</b>address, port [, backlog]<b>)</b></tt></a><p>

Creates  a new  TCP server  socket  and binds  it to  (<tt>address</tt>,
<tt>port</tt>) on the local host.  <tt>Address</tt> can be an IP address
or a host name. If <tt>address</tt> is '<tt>*</tt>', the system binds to
all local  interfaces (<tt>INADDR_ANY</tt>). If <tt>port</tt>  is 0, the
system automatically  chooses an ephemeral port.  The optional parameter
<tt>backlog</tt>  (default  value  1)  specifies the  number  of  client
connections that can be queued waiting for service. If the queue is full
and another  client attempts connection,  the connection is  refused. In
case of  success, the  function returns  a server  socket, on  which the
operations  <tt>accept</tt>,  <tt>close</tt>,  <tt>getsockname</tt>  and
<tt>listen</tt> are  permitted. In case  of error, the  function returns
<tt>nil</tt> followed by a string describing the error. <p>

<a name=tcp.close><tt><b>close(</b>socket<b>)</b></tt></a><p>

Closes  the   socket  <tt>socket</tt>.   The  local  address   to  which
<tt>socket</tt> was  bound is made  available to other  applications. No
further  operations (except  for  further calls  to <tt>close</tt>)  are
allowed on a closed socket. <p>

Note:  It is  important to  close all  used  sockets once  they are  not
needed,  since, in  many systems,  each socket  uses a  file descriptor,
which are a limited system resource. <p>

<a name=tcp.connect><tt><b>connect(</b>address, port<b>)</b></tt></a><p>

Creates   a  new   TCP   client   socket  and   tries   to  connect   to
(<tt>address</tt>, <tt>port</tt>). <tt>Address</tt> can be an IP address
or a host name. In case of success, the function returns a client socket
on   which   the    operations   <tt>close</tt>,   <tt>getsockname</tt>,
<tt>getpeername</tt>,      <tt>receive</tt>,      <tt>send</tt>      and
<tt>timeout</tt> are permitted.  In case of error,  the function returns
<tt>nil</tt> followed by a string describing the error. <p>

<a name=tcp.getpeername><tt><b>getpeername(</b>socket<b>)</b></tt></a><p>

Returns the IP address and port of  the peer connected to the TCP client
<tt>socket</tt> or <tt>nil</tt> in case of  error. Note that it makes no
sense to call <tt>getpeername</tt> on a server socket object. <p>

<a name=tcp.getsockname><tt><b>getsockname(</b>socket<b>)</b></tt></a><p>

Returns the local IP address and port of the TCP <tt>socket</tt>
or <tt>nil</tt> in case of error. <p>

<a name=tcp.receive><tt><b>receive(</b>socket [, pattern<sub>1</sub></tt>, <tt>pattern</tt><sub>2</sub>, ... <tt>pattern</tt><sub>N</sub>]<b><tt>)</tt></b></a><p>

Receives <tt>pattern</tt><sub>1</sub>, <tt>pattern</tt><sub>2</sub>, ...
<tt>pattern</tt><sub>N</sub> from the  client <tt>socket</tt>. A pattern
can be one of the following:

<ul>

<li>  '<tt>*a</tt>':  reads from  the  socket  until the  connection  is
closed. No end-of-line translation is performed;

<li> '<tt>*l</tt>':  reads a line of  text from the socket.  The line is
terminated by a  LF character (ASCII&nbsp;10), optionally  preceded by a
CR character (ASCII&nbsp;13). The CR and LF characters are not returned.
This is the default pattern;

<li> '<tt>*lu</tt>': reads  a line of text from the  socket. The line is
assumed to be  terminated by a single LF character.  If the LF character
is is preceded  by a CR character,  the CR character is  returned in the
string, whereas the LF character is not;

<li> '<tt>*w</tt>':  reads a word (maximal  sequence of non-white-space
characters), skipping leading spaces if necessary;

<li> <tt>number</tt>:  causes the  function to read  <tt>number</tt> raw
bytes from the socket. 

</ul>

The function  returns one value for  each pattern, followed by  a single
error  code that  can be  <tt>nil</tt> in  case of  success, the  string
'<tt>closed</tt>'  in   case  the  connection  was   closed  before  the
transmission  was completed  or  the string  '<tt>timeout</tt>' in  case
there was a timeout during  the operation. The difference in performance
between all patterns is negligible. <p>

Note: In case of error, the function always return everything it managed
to download before the error condition was met. <p>

<a name=tcp.select><tt><b>select(</b>receive, send [, timeout]<b>)</b></tt></a><p>

Waits for  a number of sockets  to change status. <tt>Receive</tt>  is a
table with  the sockets  to test for  characters available  for reading.
Sockets in  the <tt>send</tt> table  are watched to see  if it is  OK to
immediately write  on them.  <tt>Timeout</tt> is  the maximum  amount of
time  (in seconds)  to  wait for  a change  in  status. A  <tt>nil</tt>,
negative or omitted <tt>timeout</tt> value  allows the function to block
indefinitely.  <tt>Receive</tt>  and  <tt>send</tt> can  also  be  empty
tables or <tt>nil</tt>. Non-socket values in the tables will be silently
ignored (that way you can have a handy field named <tt>"n"</tt>). <p>

The function returns a table with the sockets ready for reading, a table
with  the sockets  ready for  writing and  an error  message. The  error
message is  "timeout" if  a timeout condition  was met  and <tt>nil</tt>
otherwise. <p>

Important Note:  a known  bug in  WinSock prevents  <tt>select</tt> from
working properly on non-blocking TCP  sockets. The function may return a
socket as <i>writable</i> even though the socket is <i>not</i> ready for
sending. <p>

Note:   calling   <tt>select</tt>   with   a  server   socket   in   the
<tt>receive</tt>  parameter  before  a   call  to  <tt>accept</tt>  does
<i>not</i> guarantee  <tt>accept</tt> will  return immediately.  Use the
<tt>timeout</tt>  server socket  method or  <tt>accept</tt> <i>might</i>
block forever. <p>

Interesting note: as mentioned in some manuals, calling <tt>select</tt> 
with both sets empty and a non-null timeout is a fairly portable way to 
sleep with sub-second precision. <p>

Examples:

<blockquote>
<pre>
-- waits for input on three sockets and broadcasts any received lines
server = bind("localhost", 8080)
a = server:accept(); b = server:accept(); c = server:accept()
a:timeout(1); b:timeout(1); c:timeout(1)
while 1 do
  r, _, e = select({a,b,c}, nil)
  for i,v in r do
    l, e = v:receive()
    if e then exit() end
    _, s, e = select(nil, {a,b,c}, 1)
    for j,u in s do
      e = u:send(l, "\n") 
      if e then exit() end
    end
  end
end

</pre>
</blockquote>

<a name=tcp.send><tt><b>send(</b>socket, string<sub>1</sub> </tt>[, <tt>string</tt><sub>2</sub>, ... <tt>string</tt><sub>N</sub>]<b><tt>)</tt></b></a><p>

Sends the strings <tt>string</tt><sub>1</sub>, 
<tt>string</tt><sub>2</sub>, ... <tt>string</tt><sub>N</sub> through the
client socket <tt>socket</tt>. The function returns an error code, which
is <tt>nil</tt> in case of success, the string '<tt>closed</tt>' in case
the connection was  closed before the transmission was  completed or the
string  '<tt>timeout</tt>'  in  case  there was  a  timeout  during  the
operation.  After the  error code,  the function  returns the  number of
bytes accepted by the transport layer. <p>

<a name=tcp.timeout><tt><b>timeout(</b>socket, value [, mode]<b>)</b></tt></a><p>

Changes the timeout  values for the socket  <tt>socket</tt>. By default,
all I/O  operations are  blocking. That  is, any  call to  the functions
<tt>send</tt> and  <tt>receive</tt> will  block indefinitely,  until the
operation completes.  The <tt>timeout</tt>  function defines a  limit on
the  amount  of   time  the  functions  can  block,   specified  as  the
<tt>value</tt> parameter,  in seconds. There  are two timeout  modes and
both can be used together for fine tuning:

<ul>
<li> '<tt>b</tt>': <i>blocked</i> timeout.  Specifies the upper limit on
the amount  of time  LuaSocket can  be blocked  by the  operating system
while waiting for completion of any single I/O operation;</li>

<li> '<tt>r</tt>':  <i>return</i> timeout. Specifies the  upper limit on
the amount of  time LuaSocket can block a Lua  script before returning a
function call.</li> </ul>

The  <tt>nil</tt>  timeout  <tt>value</tt> allows  operations  to  block
indefinitely. Negative timeout values have the same effect. <p>

Note: although  timeout values have millisecond  precision, large blocks
can cause  I/O functions not to  respect timeout values due  to the time
the library takes to  transfer blocks to and from the  kernel and to and
from the Lua interpreter. <p>

<h3><a name=udp>UDP sockets</a></h3><p>

<a name=udp.close><tt><b>close(</b>socket<b>)</b></tt></a><p>

Closes  the socket  <tt>socket</tt>. The  local address  to which  it is
bound is made available to other applications. No further operations are
allowed on a closed socket. <p>

Note:  It is  important to  close all  used  sockets once  they are  not
needed,  since, in  many systems,  each socket  uses a  file descriptor,
which are a limited system resource. <p>

<a name=udp.getpeername><tt><b>getpeername(</b>socket<b>)</b></tt></a><p>

Returns the IP address and port of  the peer of the UDP <tt>socket</tt>.
The  function will  fail unless  a  peer has  been  set with  a call  to
<tt>setpeername</tt>. <p>

<a name=udp.getsockname><tt><b>getsockname(</b>socket<b>)</b></tt></a><p>

Returns the  local IP  address and  port of  the TCP  <tt>socket</tt> or
<tt>nil</tt> in case of error. <p>

Note:   UDP   sockets    are   not   bound   to    any   address   until
<tt>setsockname</tt>  or the  <tt>sendto</tt> method  is called  for the
first time  (in which  case it  is bound  to an  ephemeral port  and the
wild-card address). The local address cannot be changed thereafter. <p>

<a name=udp.receive><tt><b>receive(</b>socket [, number]<b>)</b></tt></a><p>

Receives  a datagram  from the  UDP  socket <tt>socket</tt>  with up  to
<tt>number</tt>  bytes. If  there  are more  than <tt>number</tt>  bytes
available in  the datagram,  the remaining are  discarded. If  there are
less then <tt>number</tt>  bytes available in the  current datagram, the
available bytes are returned. If <tt>number</tt> is omitted, the maximum
datagram  size  is  used.  In case  of  timeout,  the  function  returns
<tt>nil</tt>  followed by  the  string '<tt>timeout</tt>'.  In case  the
transmission failed,  the function returns <tt>nil</tt>  followed by the
string '<tt>refused</tt>'.<p>

<a name=udp.receivefrom><tt><b>receivefrom(</b>socket [, number]<b>)</b></tt></a><p>

Works exactly  as the <tt>receive</tt>  function, except it  returns the
sender  <tt>ip</tt>  and  <tt>port</tt>   as  extra  return  values  and
is therefore slightly less efficient. <p>

<a name=udp.select><tt><b>select(</b>receive, send [, timeout]<b>)</b></tt></a><p>

Waits for  a number of sockets  to change status. <tt>Receive</tt>  is a
table with the sockets to test  for characters available for reading. OK
Sockets  in the  <tt>send</tt> table  are watched  to  see if  it is  to
immediately write  on them.  <tt>Timeout</tt> is  the maximum  amount of
time  (in seconds)  to  wait for  a change  in  status. A  <tt>nil</tt>,
negative or omitted <tt>timeout</tt> value  allows the function to block
indefinitely.  <tt>Receive</tt>  and  <tt>send</tt> can  also  be  empty
tables or <tt>nil</tt>. Non-socket values in the tables will be silently
ignored (that way you can have a handy field named <tt>"n"</tt>). <p>

The function returns a table with the sockets ready for reading, a table
with  the sockets  ready for  writing and  an error  message. The  error
message is  "timeout" if  a timeout condition  was met  and <tt>nil</tt>
otherwise. <p>

<a name=udp.send><tt><b>send(</b>socket, string<b>)</b></tt></a><p>

Sends <tt>string</tt>  to the  UDP peer  of socket  <tt>socket</tt>. The
method <tt>setpeername</tt> MUST have been called on <tt>socket</tt>. If
successful, the function  returns <tt>nil</tt>. In case  of timeout, the
function returns the string '<tt>timeout</tt>'. In case the transmission
failed, the function returns the string '<tt>refused</tt>'.<p>

<a name=udp.sendto><tt><b>sendto(</b>socket, string, ip, port<b>)</b></tt></a><p>

Sends  <tt>string</tt>  to  (<tt>ip</tt>,  <tt>port</tt>).  In  case  of
timeout, the function returns the string '<tt>timeout</tt>'. <tt>Ip</tt>
MUST be an IP address, for performance reasons. In case the transmission
failed, the function returns the string '<tt>refused</tt>'.<p>

<a name=udp.setpeername><tt><b>setpeername(</b>socket, address, port<b>)</b></tt></a><p>

Sets the <tt>socket</tt> UDP  peer to (<tt>address</tt>, <tt>port</tt>).
<tt>Address</tt> can be  an IP address or  a host name. After  a call to
<tt>setpeername</tt>,  the <tt>send</tt>  and  <tt>receive</tt> MUST  be
used  instead  of  <tt>sendto</tt>  and  <tt>receivefrom</tt>.  Outgoing
datagrams will  be sent  to the specified  peer, and  datagrams received
from other peers will  be discarded by the OS. Since  the address of the
peer does  not have to be  passed to and  from the OS, this  practice is
recommended when the same peer is used for several transmissions and can
lead to up to 30% performance gains. <p>

<a name=udp.setsockname><tt><b>setsockname(</b>socket, address, port<b>)</b></tt></a><p>

Binds   the   UDP  socket   to   a   local  address   (<tt>address</tt>,
<tt>port</tt>). <tt>Address</tt> can be an IP address or a host name. If
<tt>address</tt>  is   '<tt>*</tt>'  the  system  binds   to  all  local
interfaces  (<tt>INADDR_ANY</tt>). If  <tt>port</tt>  is  0, the  system
chooses  an   ephemeral  port.  If  successful,   the  function  returns
<tt>nil</tt>. In case  of error, the function returns  an error message.
<p>

<a name=udp.timeout><tt><b>timeout(</b>socket, value<b>)</b></tt></a><p>

Changes the  timeout value for  the socket <tt>socket</tt>.  By default,
all  operations are  blocking. The  <tt>timeout</tt> function  defines a
limit on  the amount of time  the functions can block,  specified as the
<tt>value</tt> parameter, in seconds. A <tt>nil</tt> or negative timeout
<tt>value</tt> allows operations to block indefinitely. <p>

Note:  there is  no send  buffer on  an  UDP socket.  Therefore, a  send
operation on an UDP socket should never block, regardless of the timeout
<tt>value</tt>. Receive operations, however,  can block the application.
<p>

<a name=udp.udpsocket><tt><b>udpsocket(</b>[options]<b>)</b></tt></a><p>

Creates  and  returns  an  UDP  socket  object,  on  which  the  methods
<tt>close</tt>,        <tt>getpeername</tt>,       <tt>getsockname</tt>,
<tt>receive</tt>, <tt>receivefrom</tt>,  <tt>send</tt>, <tt>sendto</tt>,
<tt>setpeername</tt>, <tt>setsockname</tt>  and <tt>timeout</tt>  can be
used. In case  of error, the function returns <tt>nil</tt>  and an error
message. <p>

The table  <tt>options</tt> allows  users to specify  non-default socket
options at socket creation time. The table must be in the format:

<blockquote>
<pre>
options = {
  ["option-1-name"] = value-1,
  ["option-2-name"] = value-2,
  ["option-3-name"] = value-3,
         ...            ...
  ["option-n-name"] = value-n
}
</pre>
</blockquote>

The supported options and their expected value types are: <p>

<ul>
<li> <tt>SO_KEEPALIVE</tt>: a <i>number</i>
<li> <tt>SO_DONTROUTE</tt>: a <i>number</i>
<li> <tt>SO_BROADCAST</tt>: a <i>number</i>
<li> <tt>SO_LINGER</tt>: a <i>table</i> in the format
    <tt>{l_onoff = </tt><i>number</i>, 
    <tt>l_linger = </tt><i>number</i><tt>}</tt>.
</ul>

Note: UDP socket options should only be used by advanced users.

<h3><a name=dns>DNS Services</a></h3><p>

The following functions can be used to convert between host names and IP
addresses. All information returned by the resolver is returned by these
functions, as a table in the form:

<blockquote>
<pre>
resolved = {
  ["name"] = "canonic-name",
  ["alias"] = alias-list,
  ["ip"] = ip-address-list
}
</pre>
</blockquote>

Note that the <tt>alias</tt> list can be empty.

<p>

<a name=dns.tohostname><tt><b>tohostname(</b>address<b>)</b></tt></a><p>

Returns a string  with the canonic host name  of given <tt>address</tt>,
followed  by a  table with  all  information returned  by the  resolver.
<tt>Address</tt> can  be an IP address  or host name. In  case of error,
the function returns <tt>nil</tt> followed by an error message. <p>

<a name=dns.toip><tt><b>toip(</b>address<b>)</b></tt></a><p>

Returns a string  with the first IP address  found for <tt>address</tt>,
followed  by a  table with  all  information returned  by the  resolver.
<tt>Address</tt> can  be an IP address  or host name. In  case of error,
the function returns <tt>nil</tt> followed by an error message. <p>

<hr>
<p align=center>
<a href="home.html">home</a> &middot;
<a href="home.html#down">download</a> &middot;
<a href="home.html#whatis">what is</a> &middot;
<a href="intro.html">introduction</a> &middot;
<a href="func.html">functions</a> &middot;
<a href="mod.html">modules</a> &middot;
<a href="idx.html">index</a> 
<p>

<table summary="Best Viewed on Any Browser and Created with Vim" align=center>
<tr> 
<td align=center> <img alt="Created with Vim" src="vim.png">
<td align=center> and
<td align=center> <img alt="Best Viewed on Any Browser" src="anybrowser.png">
<tr> <td colspan=3 align=center>
<small>
Last modified by Diego Nehab on <br>
Thu Sep 27 16:18:27 EST 2001
</small>
</table>

</body>
</html>
