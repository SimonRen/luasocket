<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>

<head>
<title>LuaSocket: IPv4 Sockets support for the Lua language </title>
<style type="text/css">
ul { list-style-type: disc };
</style>
</head>

<body bgcolor="#FFFFFF">

<hr>

<center>
<table summary="LuaSocket logo" border=0 cellspacing=0 cellpadding=0>
<tr><td align=center>
<a href="http://www.lua.org">
<img border=0 alt="LuaSocket" src="luasocket.png">
</a>
<tr><td align=center valign=top>IPv4 Sockets support for the Lua language
</table>
</center>

<p align=center>
<a href="home.html">home</a> &middot;
<a href="home.html#down">download</a> &middot;
<a href="home.html#whatis">what is</a> &middot;
<a href="intro.html">introduction</a> &middot;
<a href="func.html">functions</a> &middot;
<a href="mod.html">modules</a> &middot;
<a href="idx.html">index</a> 
<p>

<hr>

<h2> <a name=proto> Protocol Reference </a></h2> <p>

Besides  IPv4  transport layer  support,  the  LuaSocket toolkit  offers
straightforward  support  for the  HTTP,  SMTP  and FTP  protocols.  The
support is implemented in the Lua  language and is distributed in source
code as three separate modules.

<h3> <a name=stream> Streaming with callbacks </a> </h3> <p>

HTTP and FTP  transfers sometimes involve large  amounts of information.
Sometimes an application  needs to generate outgoing data  in real time,
or needs  to process incoming  information as  it is being  received. To
address these  problems, LuaSocket  allows HTTP  message bodies  and FTP
file  contents to  be received  or sent  through the  callback mechanism
outlined below. <p>

Instead of  returning the whole contents  of a FTP file  or HTTP message
body as  strings to the Lua  application, the library allows  the user to
provide a  <i>receive callback</i> that  will be called  with successive
chunks of data, as the data becomes available: <p>

<blockquote>
<a name=receive_cb><tt><b>receive_cb(</b>chunk, err<b>)</b></tt></a><p>

The  callback provided  by the  user will  be repeatedly  called by  the
library whenever  new data  is available.  Each time  it is  called, the
callback receives  successive <tt>chunks</tt>  of downloaded  data. When
the transmission  is over, the function  is called with an  empty string
(i.e.&nbsp;<tt>""</tt>) as  the <tt>chunk</tt>. If an  error occurs, the
function  receives a  <tt>nil</tt> chunk  and  an error  message as  the
<tt>err</tt> argument. The callback  can abort transmission by returning
<tt>nil</tt> as its first return value. In that case, it can also return
an error  message. Any non-<tt>nil</tt>  return value proceeds  with the
transmission. <p>

Examples:<br>
<blockquote>
<pre>
-- saves incoming file to disk, receiving chunk by chunk
local file = openfile(tmpname(), "wb")       -- open temp file for writing
local receive_cb = function(chunk, err)
    if chunk and chunk ~= "" then
        local res, err = write(%file, chunk) -- try to write to disk
        if not res then return nil, err      -- woops! abort with error message
        else return 1 end                    -- all is ok, please go on
    else closefile(%file) end                -- we are done
end

-- print throughput feedback while receiving data
local aux = { start = _time(), got = 0 }     -- auxiliar table
local receive_cb = function(chunk, err)
    local dt = _time() - %aux.start          -- elapsed time since start
    if not chunk or chunk == "" then return end
    %aux.got = %aux.got + strlen(chunk)      -- total bytes received
    if dt < 0.1 then return 1 end            -- not enough time for estimate
    local rate = %aux.got / dt               -- get download rate
    write("\r" .. format("%.2f", rate))      -- print estimate
    return 1                                 -- ready for more
end

</pre>
</blockquote>
</blockquote>

Instead  of forcing  the  Lua application  to pass  the  whole FTP  file
contents or  the HTTP request message  body as a string  to the library,
the library allows the user to  provide a <i>send callback</i> that will
be  called repeatedly  to  return successive  parts  of the  information
needed by the library: <p>

<blockquote>
<a name=send_cb><tt><b>send_cb()</b></tt></a><p>

The callback provided by the user will be repeatedly called whenever the
library needs more data to be sent. Each time the callback is called, it
should return the next part of the information the library is expecting,
followed by the total number of bytes to be sent. The callback can abort
the  process  at any  time  by  returning  <tt>nil</tt> followed  by  an
optional error message. <p>

Obs: The need for the second return value comes from the fact that, with
the HTTP protocol for instance, the library needs to know in advance the
total number of bytes that will be sent. <p>

Examples:<br>
<blockquote>
<pre>
-- sends data from file, in blocks of 4096 bytes
local file = openfile("words", "rb")         -- open file for reading
local size = seek(file, "end")               -- get file size 
seek(file, "set")                            
local send_cb = function()
    local chunk = read(%file, 4096)          -- try to read chunk
    if not chunk then                        -- are we done?
        closefile(%file) 
        return "", %size 
    else return chunk, %size end             -- if not, send what we got
end

-- sends everything in the first call
local file = openfile("words", "rb")         -- open file for reading
local data = read(file, "*a")
closefile(file)
local send_cb = function()
    return %data, strlen(%data)              -- return everything
end

</pre>
</blockquote>
</blockquote>

<h3> <a name=http> HTTP </a></h3> <p>

HTTP (Hyper Text  Transfer Protocol) is the protocol  used to exchange
information  between  web-browsers and  servers.  The  <tt>http.lua</tt>
module offers  support for the client  side of the HTTP  protocol (i.e.,
the facilities that would be  used by a web-browser implementation). The
implementation    conforms     to    the    HTTP/1.1     standard,    
<a href="http://www.tecgraf.puc-rio.br/~diego/rfc/rfc2616.txt">RFC 2616</a>. 
<p>

URLs MUST conform to 
<a href="http://www.tecgraf.puc-rio.br/~diego/rfc/rfc1738.txt">RFC 1738</a>, 
that is, an URL is a string in the form: <p>

The module exports functions that provide HTTP functionality in different
levels of abstraction, from a simple <a href="#HTTP.get"><tt>HTTP.get</tt></a>,
to a complete callback oriented <a href="#HTTP.request_cb">
<tt>HTTP.request_cb</tt></a>.<p>

<blockquote>
<pre>[http://][&lt;user&gt;[:&lt;password&gt;]@]&lt;&gt;[:&lt;port&gt;][/&lt;path&gt;] </pre>
</blockquote>

MIME Headers are represented as a table in the form:<p>

<blockquote>
<pre>
headers = {
  ["field-1-name"] = "field-1-value",
  ["field-2-name"] = "field-2-value",
  ["field-3-name"] = "field-3-value",
         ...               ...
  ["field-n-name"] = "field-n-value"
}
</pre>
</blockquote>

Field names are case insensitive (as  specified by the standard) and all
API functions  work with  lowercase field names.  Field values  are left
unmodified.<p>

<a name=HTTP.get><tt><b>HTTP.get(</b>url<b>)</b></tt></a> or <br>
<tt><b>HTTP.get{</b><br>
&nbsp;&nbsp;url = <i>string</i>,<br>
&nbsp;&nbsp;headers = <i>header table</i>,<br>
&nbsp;&nbsp;user = <i>string</i>,<br>
&nbsp;&nbsp;password = <i>string</i>,<br>
&nbsp;&nbsp;stay = <i>bool</i>,<br>
<b>}</b></tt><p>

Performs  method '<tt>GET</tt>'  on  <tt>url</tt>. The  function can  be
called either directly with a <tt>url</tt>  or with a request table. The
use of  a request table allows  complete control over the  components of
the  request. 
Values  passed explicitly  in the  request table  override
those given by the <tt>url</tt>.<p>

The function  returns the response  message body, the mime  headers, the
status  code and  an  error message  if  any. In  case  of failure,  the
function returns all information it managed to gather. <p>

Note: The function is trivially implemented with the use of the
<a href="#HTTP.request"><tt>HTTP.request</tt></a> function. <p>

Examples: <br>
<blockquote>
<pre>
-- connect to server "www.tecgraf.puc-rio.br" and retrieves this manual
-- file from "~diego/luasocket/mod.html"
b, h, c, e = HTTP.get("http://www.tecgraf.puc-rio.br/~diego/luasocket/manual.html")

-- connect to server "www.tecgraf.puc-rio.br" and tries to retrieve
-- "~diego/auth/index.html". Fails because authentication is needed.
b, h, c, e = HTTP.get("http://www.tecgraf.puc-rio.br/~diego/mark/index.html")
-- b returns some useless page, h returns authentication information 
-- and c returns with value 401 (Authentication Required)

-- tries to connect to server "wrong.host" to retrieve "/" 
-- and fails because the host does not exist.
b, h, c, e = HTTP.get("http://wrong.host/")
-- b, h, c are nil, and e returns with value "host not found"

</pre>
</blockquote>

<a name=HTTP.post><tt><b>HTTP.post(</b>url, body<b>)</b></tt></a> or<br>
<tt><b>HTTP.post{</b><br>
&nbsp;&nbsp; url = <i>string</i>,<br>
&nbsp;&nbsp; headers = <i>header table</i>,<br>
&nbsp;&nbsp; body = <i>string</i>,<br>
&nbsp;&nbsp; user = <i>string</i>,<br>
&nbsp;&nbsp; password = <i>string</i>,<br>
&nbsp;&nbsp; stay = <i>bool</i>,<br>
<b>}</b></tt><p>

Same  as <a  href="#HTTP.get"><tt>HTTP.get</tt></a>,  except the  method
used is  '<tt>POST</tt>' and the  request message <tt>body</tt>  is sent
along with the request. <p>

<a name=HTTP.request><tt><b>HTTP.request{</b><br>
&nbsp;&nbsp;method = <i>string</i>,<br>
&nbsp;&nbsp;url = <i>string</i>,<br>
&nbsp;&nbsp;headers = <i>header table</i>,<br>
&nbsp;&nbsp;body = <i>string</i>,<br>
&nbsp;&nbsp;user = <i>string</i>,<br>
&nbsp;&nbsp;password = <i>string</i>,<br>
&nbsp;&nbsp;stay = <i>string</i>,<br>
<b>}</b></tt></a><p>

Performs the generic HTTP  request using <tt>method</tt> on <tt>url</tt>
sending the  request <tt>headers</tt>  and request <tt>body</tt>  in the
request message. If authentication information is provided, the function
uses the  Basic Authentication Scheme (see  <a href="#auth_note">note</a>)
to retrieve  the document. <tt>User</tt> and  <tt>password</tt> provided
explicitly override  those given by the  <tt>url</tt>. The <tt>stay</tt>
parameter, when set to anything  but <tt>nil</tt>, prevents the function
from automatically following 301 or 302 server redirect messages. <p>

The function returns a table with all components of the response message
it managed to retrieve. The response table has the following form:<p>

<blockquote>
<tt>response = {<br>
&nbsp;&nbsp;body = <i>string</i>,<br>
&nbsp;&nbsp;headers = <i>header table</i>,<br>
&nbsp;&nbsp;status = <i>string</i>,<br>
&nbsp;&nbsp;code = <i>number</i>,<br>
&nbsp;&nbsp;error = <i>string</i>,<br>
}</tt>
</blockquote>


Note: Even  when there  was failure  (URL not  found, for  example), the
function may succeed retrieving a message body (a web page informing the
URL  was  not found  or  some  other useless  page).  To  make sure  the
operation was successful, check  the returned status <tt>code</tt>. For
a  list  of  the  possible  values  and  their  meanings,  refer  to  <a
href="http://www.tecgraf.puc-rio.br/~diego/rfc/rfc2616.txt">RFC
2616</a>. <p>

Example:<br>
<blockquote>
<pre>
-- request information about a document, without downloading it.
-- useful, for example, if you want to display a download gauge and need
-- to know the size of the document in advance
response = HTTP.request {
  method = "HEAD",
  url = "http://www.tecgraf.puc-rio.br/~diego"
}
-- would return the following headers: 
-- response.headers = {
--   date = "Tue, 18 Sep 2001 20:42:21 GMT",
--   server = "Apache/1.3.12 (Unix)  (Red Hat/Linux)",
--   ["last-modified"] = "Wed, 05 Sep 2001 06:11:20 GMT",
--   etag = '"c1513-3d24-3b95c208"',
--   ["accept-ranges"] = "bytes",
--   ["content-length"] = 15652,
--   ["connection"] = "close",
--   ["content-Type"] = "text/html"
-- }

</pre>
</blockquote>

<a name=auth_note> Authentication Note:</a> Some URLs are protected by their
servers from anonymous download. For those URLs, the server must receive
some  sort of  authentication along  with the  request or  it will  deny
download and return status "401 Authentication Required". <p>

The  HTTP/1.1 standard  defines  two authentication  methods: the  Basic
Authentication  Scheme  and  the   Digest  Authentication  Scheme,  both
explained in detail in
<a href="http://www.tecgraf.puc-rio.br/~diego/rfc/rfc2068.txt">RFC 2068</a>.
<p>

The   Basic  Authentication   Scheme  sends   <tt>&lt;user&gt;</tt>  and
<tt>&lt;password&gt;</tt>  unencrypted to  the server  and is  therefore
considered unsafe.  Unfortunately, by  the time of  this implementation,
the wide majority of servers and browsers support the Basic Scheme only.
Therefore,   this  is   the  method   used  by   the  toolkit   whenever
authentication is required.<p>

Authentication Example:<br>
<blockquote>
<pre>
-- connect to server "www.tecgraf.puc-rio.br" and tries to retrieve
-- "~diego/auth/index.html", using the provided name and password to
-- authenticate the request
response = HTTP.request{
  url = "http://www.tecgraf.puc-rio.br/~diego/auth/index.html",
  user = "diego",
  password = "password"
}

-- alternatively, one could fill the appropriate header and authenticate
-- the request directly.
headers = {
  authentication = "Basic " .. Code.base64("diego:password")
}
response = HTTP.request {
  url = "http://www.tecgraf.puc-rio.br/~diego/auth/index.html",
  headers = headers
}
</pre>
</blockquote>

<a name=HTTP.request_cb><tt><b>HTTP.request_cb(</b>request, response<b>)</b></tt></a><br>
<tt>
request = {<br>
&nbsp;&nbsp;method = <i>string</i>,<br>
&nbsp;&nbsp;url = <i>string</i>,<br>
&nbsp;&nbsp;headers = <i>header table</i>,<br>
&nbsp;&nbsp;body_cb = <i>send callback</i>,<br>
&nbsp;&nbsp;user = <i>string</i>,<br>
&nbsp;&nbsp;password = <i>string</i>,<br>
&nbsp;&nbsp;stay = <i>string</i>,<br>
}</tt><br>
<tt>
response = {<br>
&nbsp;&nbsp;body_cb = <i>receive callback</i><br>
}</tt>
<p>

Performs the generic HTTP  request using <tt>method</tt> on <tt>url</tt>
sending the <tt>request.headers</tt> along with the request. The request
message  body  is  sent  with   the  use  of  the  <i>send  callback</i>
<tt>request.body_cb</tt>. If authentication information is provided, the
function    uses   the    Basic    Authentication    Scheme   (see    <a
href="#auth_note">note</a>)  to retrieve  the document.  <tt>User</tt> and
<tt>password</tt>  provided  explicitly  override  those  given  by  the
<tt>url</tt>.  The <tt>stay</tt>  parameter,  when set  to anything  but
<tt>nil</tt>, prevents the function  from automatically following 301 or
302 server redirect messages. <p>

The function  returns the same  response table  as that returned  by the
<tt>HTTP.request</tt>  function, except  the  response  message body  is
returned    to    the    <i>receive   callback</i>    given    by    the
<tt>response.body_cb</tt> field. <p>

Note: for more information on callbacks, refer to 
<a href="#stream">Streaming with callbacks</a>.<p>

Examples:<br>
<blockquote>
<pre>
-- The implementation of the HTTP.request function
function Public.request(request)
    local response = {}
    if request.body then
        request.body_cb = function()
            return %request.body, strlen(%request.body)
        end
    end
    local cat = Concat.create()
    response.body_cb = function(chunk, err)
        if chunk then %cat:addstring(chunk) end
        return 1
    end
    response = %Public.request_cb(request, response)
    response.body = cat:getresult()
    response.body_cb = nil
    return response
end

</pre>
</blockquote>

<h3> <a name=FTP> FTP </a> </h3> <p>

FTP  (File Transfer  Protocol)  is a  protocol  used  to transfer  files
between hosts.  The module  <tt>ftp.lua</tt> offers simple  FTP support,
allowing applications to  download and upload files,  and list directory
contents. The implementation conforms to
<a href="http://www.tecgraf.puc-rio.br/~diego/rfc/rfc0959.txt">RFC 959</a>. 
<p>

URLs MUST conform to 
<a href="http://www.tecgraf.puc-rio.br/~diego/rfc/rfc1738.txt">RFC 1738</a>, 
that is, an URL is a string in the form: <p>

<blockquote>
<tt>
[ftp://][&lt;user&gt;[:&lt;password&gt;]@]&lt;&gt;[:&lt;port&gt;][/&lt;path&gt;][<i>type</i>=a|i|d]</tt>
</blockquote>

<a name=FTP.get><tt><b>FTP.get(</b>url<b>)</b></tt></a> or <br>
<tt><b>FTP.get{</b><br>
&nbsp;&nbsp;url = <i>string</i>,<br>
&nbsp;&nbsp;type = <i>string</i>,<br>
&nbsp;&nbsp;user = <i>string</i>,<br>
&nbsp;&nbsp;password = <i>string</i><br>
<b>}</b></tt><p>

Downloads the URL <tt>url</tt> and returns  it as a string. The function
can be  called either  directly with  a <tt>url</tt>  or with  a request
table.  Values passed  explicitly in  the request  table override  those
given by the <tt>url</tt>.<p>

The parameter <tt>type</tt> can  receive values '<tt>a</tt>' (ASCII, the
default), '<tt>i</tt>' (binary) or  '<tt>d</tt>' (directory listing) and
determines  the  transfer type.  If  <tt>&lt;path&gt;</tt>  ends with  a
'<tt>/</tt>' or  <tt>type</tt> is  '<tt>d</tt>', a directory  listing of
<tt>&lt;path&gt;</tt> is  returned. If successful, the  function returns
the file  contents as a string.  In case of error,  the function returns
<tt>nil</tt> and an error message describing the error. <p>

If no <tt>user</tt> is provided in the <tt>url</tt> or explicitly, 
the function tries to log in as user '<tt>anonymous</tt>'.<p>

Examples:<br>
<blockquote>
<pre>
-- log as user "anonymous" on server "ftp.tecgraf.puc-rio.br"
-- go to directory "pub/lua" and get file "lua.tar.gz" as binary.
f, e = FTP.get("ftp://ftp.tecgraf.puc-rio.br/pub/lua/lua.tar.gz;type=i")

-- log as user "anonymous" on server "ftp.tecgraf.puc-rio.br"
-- go to director "pub" and retrieve directory listing of directory "lua"
f, e = FTP.get("ftp://ftp.tecgraf.puc-rio.br/pub/lua;type=d")

-- log as user "diego", password "nehab", on server "derain.tecgraf.puc-rio.br"
-- go to directory "tec/luasocket/bin" and retrieve file "luasocket.exe"
-- (actually, fails because of wrong password :-)
f, e = FTP.get{
  url = "ftp://derain.tecgraf.puc-rio.br/tec/luasocket/bin/luasocket.exe",
  user = "diego",
  password = "nehab",
  type = "i"
}
-- f returns nil, and e returns an appropriate error message

</pre>
</blockquote>

<a name=FTP.put><tt><b>FTP.put(</b>url, content<b>)</b></tt></a> or <br>
<tt><b>FTP.put{</b><br>
&nbsp;&nbsp;url = <i>string</i>,<br>
&nbsp;&nbsp;content = <i>string</i>,<br>
&nbsp;&nbsp;type = <i>string</i>,<br>
&nbsp;&nbsp;user = <i>string</i>,<br>
&nbsp;&nbsp;password = <i>string</i><br>
<b>}</b></tt><p>

Stores  a  file  at  <tt>url</tt> with  contents  given  by  the  string
<tt>content</tt>.   The  function   can  be   called  directly   with  a
<tt>url</tt> and  <tt>content</tt> parameters, or with  a request table.
Values passed  explicitly in the  request table override those  given by
the   <tt>url</tt>.   The   parameter   <tt>type</tt>   receive   values
'<tt>a</tt>'  (ASCII,   the  default)   or  '<tt>i</tt>'   (binary)  and
determines  the transfer  type.  If no  <tt>user</tt>  is provided,  the
function tries to log in as '<tt>anonymous</tt>'.<p>

If successful, the function returns  <tt>nil</tt>. In case of error, the
function returns a string describing the error. <p>

Examples: <br>
<blockquote>
<pre>
-- log as user "anonymous" on server "ftp.free.org" and store file
-- "hello" with contents "hello world!" on current directory, using binary
-- mode for the transfer
e = FTP.put("ftp://ftp.free.org/hello;type=i", "hello world!\n")

-- does exactly the same, but logging in as diego
e = FTP.put{
  url = "ftp://ftp.free.org/hello",
  type = "i",
  user = "diego",
  content = "hello world\n"
}

</pre>
</blockquote>

<a name=FTP.get_cb><tt>
<b>FTP.get_cb{</b><br>
&nbsp;&nbsp;url = <i>string</i>,<br>
&nbsp;&nbsp;type = <i>string</i>,<br>
&nbsp;&nbsp;content_cb = <i>receive callback</i>,<br>
&nbsp;&nbsp;user = <i>string</i>,<br>
&nbsp;&nbsp;password = <i>string</i><br>
<b>}</b></tt></a><p>

Same as <a href="#FTP.get"><tt>FTP.get</tt></a>, but the library returns
the  contents of  the  downloaded file  to  the <i>receive  callback</i>
<tt>content_cb</tt>. <p>

Note: for more information on callbacks, refer to 
<a href="#stream">Streaming with callbacks</a>.<p>

<a name=FTP.put_cb><tt>
<b>FTP.put_cb{</b><br>
&nbsp;&nbsp;url = <i>string</i>,<br>
&nbsp;&nbsp;type = <i>string</i>,<br>
&nbsp;&nbsp;content_cb = <i>send callback</i>,<br>
&nbsp;&nbsp;user = <i>string</i>,<br>
&nbsp;&nbsp;password = <i>string</i><br>
<b>}</b></tt></a><p>

Same as <a href="#FTP.put"><tt>FTP.put</tt></a>, but the library obtains
the contents of  the file to be uploaded using  the <i>send callback</i>
<tt>content_cb</tt>. <p>

Note: for more information on callbacks, refer to 
<a href="#stream">Streaming with callbacks</a>.<p>

<h3> <a name=SMTP> SMTP </a></h3> <p>

The  module  <tt>smtp.lua</tt>  provides functionality  to  send  e-mail
messages to a SMTP mail server. The implementation conforms to
<a href="http://www.tecgraf.puc-rio.br/~diego/rfc/rfc0821.txt">RFC 821</a>.<p>

MIME Headers are represented as a table in the form:<p>

<blockquote>
<pre>
headers = {
  ["field-1-name"] = "field-1-value",
  ["field-2-name"] = "field-2-value",
  ["field-3-name"] = "field-3-value",
         ...               ...
  ["field-n-name"] = "field-n-value"
}
</pre>
</blockquote>

<a name=SMTP.mail><tt><b>SMTP.mail{</b><br>
&nbsp;&nbsp;from = <i>string</i>,<br>
&nbsp;&nbsp;rcpt = <i>string</i> or <i>string table</i>,<br>
&nbsp;&nbsp;body = <i>string</i>,<br>
&nbsp;&nbsp;headers = <i>headers table</i>,<br>
&nbsp;&nbsp;server = <i>string</i><br>
<b>}</b></tt></a><p>

Sends a message to recipient list <tt>rcpt</tt>, a lua table. The sender
is given by the e-mail address <tt>from</tt>. The message is composed by
the optional  MIME Headers <tt>headers</tt> and  text <tt>body</tt>. The
message is  sent using  the server  <tt>server</tt>. If  successful, the
function returns  <tt>nil</tt>, otherwise an error  message is returned.
<p>

Examples: <br>
<blockquote>
<pre>
headers = {
  to = "fulano@tecgraf.puc-rio.br, beltrano@tecgraf.puc-rio.br",
  subject = "LuaSocket test message"
}
from = "luasocket@tecgraf.puc-rio.br"
rcpt = {
  "fulano@tecgraf.puc-rio.br",
  "beltrano@tecgraf.puc-rio.br",
  "sicrano@tecgraf.puc-rio.br"
}
body = "This is a test message. Please ignore."
server = "local"
-- connects to server "local" and sends a message to users 
-- "fulano@tecgraf.puc-rio.br" and "beltrano@tecgraf.puc-rio.br".
-- "sicrano@tecgraf.puc-rio.br" receives a 'blind carbon copy' of the message.
e = SMTP.mail(from, rcpt, headers, body, server)

</pre>
</blockquote>

<a name=cgilua.mail><tt><b>mail{</b><br>
&nbsp;&nbsp;to=<i>tolist</i>,<br>
&nbsp;&nbsp;from=<i>from</i>,<br>
&nbsp;&nbsp;subject=<i>subject</i>,<br>
&nbsp;&nbsp;message=<i>message</i>,<br>
&nbsp;&nbsp;cc=<i>cclist</i>,<br>
&nbsp;&nbsp;bcc=<i>bcclist</i>,<br>
&nbsp;&nbsp;mailserver=<i>server</i><br>
<b>}</b></tt></a><p>

The module <tt>cl-compat.lua</tt> implements a function <tt>mail</tt> that
is compatible with the interface used by 
<a href="http://www.tecgraf.puc-rio.br/cgilua">CGILua 3.2</a>.

<blockquote>
<table summary="Description of parameters">
<tr><td><i>to</i>:</td><td>A comma-separated list of the e-mails of 
    the recipients of the message.</td> </tr>
<tr><td><i>from</i>:</td><td>The email of the sender.</td></tr>
<tr><td><i>subject</i>:</td><td> Optional message subject.</td></tr>
<tr><td><i>message</i>:</td><td> Optional message body. </td></tr>
<tr><td><i>cc</i>:</td><td> An optional comma-separated list of the 
    e-mails of "carbon-copy" recipients. </td></tr>
<tr><td><i>bcc</i>:</td><td> An optional comma-separated list of the 
    e-mails of the "blind carbon-copy" recipients. </td></tr>
<tr><td><i>mailserver</i>:</td><td> Address of SMTP server to be used.</td></tr> </table>
</blockquote>
<p>

The function returns <tt>nil</tt> if  the message was sent successfully.
In case of error, an error message is returned.<p>

<h2> <a name=extra> Extra modules </a> </h2> <p>

During the development  of the HTTP, FTP and SMTP  modules, some support
routines  became useful  enough  that they  deserved  to  be placed  in
separate modules. The  two modules described below are  now supported on
their own and will also be improved with time.

<h3> <a name=extra> URL </a> </h3> <p>

The  module  <tt>url.lua</tt>  provides  functions  to  parse,  protect,
and compose URLs, as well  as functions to build  absolute URLs
from base and relative URLs, according to 
<a href="http://www.tecgraf.puc-rio.br/~diego/rfc/rfc2396.txt">RFC 2396</a>.
<p>

<a name=URL.parse_url><tt><b>URL.parse_url(</b>url, default<b>)</b></tt></a><p>

Returns a table with <tt>url</tt> parsed into all its components. A url is
defined by the following grammar: 

<blockquote>
<tt>
&lt;url&gt; ::= [&lt;scheme&gt;:][//&lt;authority&gt;][/&lt;path&gt;][;&lt;params&gt;][?&lt;query&gt;][#&lt;fragment&gt;]<br>
&lt;authority&gt; ::= [&lt;userinfo&gt;@]&lt;host&gt;[:&lt;port&gt;]<br>
&lt;userinfo&gt; ::= &lt;user&gt;[:&lt;password&gt;]<br>
&lt;path&gt; ::= {&lt;segment&gt;/}&lt;segment&gt;<br>
</tt>
</blockquote>

The returned table is of  the form:

<blockquote>
<tt>
parsed_url = {<br>
&nbsp;&nbsp;url = <i>string</i>,<br>
&nbsp;&nbsp;scheme = <i>string</i>,<br>
&nbsp;&nbsp;authority = <i>string</i>,<br>
&nbsp;&nbsp;path = <i>string</i>,<br>
&nbsp;&nbsp;params = <i>string</i>,<br>
&nbsp;&nbsp;query = <i>string</i>,<br>
&nbsp;&nbsp;fragment = <i>string</i>,<br>
&nbsp;&nbsp;userinfo = <i>string</i>,<br>
&nbsp;&nbsp;host = <i>string</i>,<br>
&nbsp;&nbsp;port = <i>string</i>,<br>
&nbsp;&nbsp;user = <i>string</i>,<br>
&nbsp;&nbsp;password = <i>string</i><br>
}</tt><br>
</blockquote>

Examples: <br>
<blockquote>
<pre>
parsed_url = URL.parse_url("http://www.puc-rio.br/~diego/index.lua?a=2#there")
-- parsed_url = {
--   scheme = "http",
--   authority = "www.puc-rio.br",
--   path = "/~diego/index.lua"
--   query = "a=2",
--   fragment = "there",
--   host = "www.puc-rio.br",
-- }

parsed_url = URL.parse_url("ftp://root:passwd@unsafe.org/pub/virus.exe;type=i")
-- parsed_url = {
--   scheme = "ftp",
--   authority = "root:passwd@unsafe.org",
--   path = "/pub/virus.exe",
--   params = "type=i",
--   userinfo = "root:passwd",
--   host = "unsafe.org",
--   user = "root",
--   password = "passwd",
-- }

</pre>
</blockquote>

<a name=URL.build_url><tt><b>URL.build_url(</b>parsed_url<b>)</b></tt></a><p>

Rebuilds an URL from its parts. The lower level components, if specified
take  precedence over  hight level  components of  the URL  grammar. The
accepted components are the same components returned by
<a href="#URL.parse_url"><tt>URL.parse_url</tt></a>, that is: <p>

<blockquote>
<tt>
&lt;url&gt; ::= [&lt;scheme&gt;:][//&lt;authority&gt;][/&lt;path&gt;][;&lt;params&gt;][?&lt;query&gt;][#&lt;fragment&gt;]<br>
&lt;authority&gt; ::= [&lt;userinfo&gt;@]&lt;host&gt;[:&lt;port&gt;]<br>
&lt;userinfo&gt; ::= &lt;user&gt;[:&lt;password&gt;]<br>
&lt;path&gt; ::= {&lt;segment&gt;/}&lt;segment&gt;<br>
</tt>
</blockquote>

The  function  receives  a  table with  the  <tt>parsed_url</tt>  to  be
reassembled and returns the corresponding URL as a result. <p>

<a name=URL.build_absolute><tt><b>URL.build_absolute(</b>base, relative<b>)</b></tt></a><p>

Builds an absolute URL from a base URL and a relative URL. The rules that
govern the composition are fairly complex, and are described in detail in
<a href="http://www.tecgraf.puc-rio.br/~diego/rfc/rfc2396.txt">RFC 2396</a>.
The following examples come from the RFC and should give an idea of the
rules.<p>

Examples: <br>

<blockquote>
Within an object with a well-defined base URI of

	<blockquote>
      <tt>http://a/b/c/d;p?q</tt>
	</blockquote>

the relative URI would be resolved as follows:

	<blockquote>
<pre>
g:h      =  g:h
g        =  http://a/b/c/g
./g      =  http://a/b/c/g
g/       =  http://a/b/c/g/
/g       =  http://a/g
//g      =  http://g
?y       =  http://a/b/c/?y
g?y      =  http://a/b/c/g?y
#s       =  http://a/b/c/d;p?q#s
g#s      =  http://a/b/c/g#s
g?y#s    =  http://a/b/c/g?y#s
;x       =  http://a/b/c/;x
g;x      =  http://a/b/c/g;x
g;x?y#s  =  http://a/b/c/g;x?y#s
.        =  http://a/b/c/
./       =  http://a/b/c/
..       =  http://a/b/
../      =  http://a/b/
../g     =  http://a/b/g
../..    =  http://a/
../../   =  http://a/
../../g  =  http://a/g
</pre>
	</blockquote>

</blockquote>

<a name=URL.parse_path><tt><b>URL.parse_path(</b>path<b>)</b></tt></a><p>

Parses  a <tt>path</tt>  component  into all  its  segments. Since  some
characters   are   reserved   in   URLs,  their   occurrences   in   the
<tt>&lt;path&gt;</tt> component of a URL  must be escaped. After parsing
the segments, the function unescapes all  of them, returning a list with
all segments. <p>

<a name=URL.build_path><tt><b>URL.build_path(</b>segments, unsafe<b>)</b></tt></a><p>

Builds a  path component from  a list of path  <tt>segments</tt>. Before
composition, any reserved characters found in a segment are escaped into
their protected  form, so that  the resulting path  is a valid  URL path
component.  If <tt>unsafe</tt>  is anything  but <tt>nil</tt>,  reserved
characters  are   left  untouched.   The  function  returns   the  built
<tt>&lt;path&gt;</tt> component. <p>

<h3> <a name=extra> Code </a> </h3> <p>

The <tt>code.lua</tt> module  offers routines to convert  back and forth
some common types of content encoding, including Base 64 and URL
escaping. Base 64 is described in
<a href="http://www.tecgraf.puc-rio.br/~diego/rfc/rfc2045.txt">RFC 2045</a>,
URL escaping is described in 
<a href="http://www.tecgraf.puc-rio.br/~diego/rfc/rfc2396.txt">RFC 2396</a>.<p>

<a name="mod.html#Code.base64"><tt><b>Code.base64(</b>content, single<b>)</b></tt></a><p>

Applies the Base  64 content coding to the  string <tt>content</tt>. The
result  is a  string with  76 characters  maximum length  lines. If  the
parameter  <tt>single</tt>  is set  to  anything  but <tt>nil</tt>,  the
output is returned as a single line.<p>

Examples: <br>
<blockquote>
<pre>
code = Code.base64("diego:password")
-- code = "ZGllZ286cGFzc3dvcmQ="

</pre>
</blockquote>

<a name="mod.html#Code.unbase64"><tt><b>Code.unbase64(</b>content<b>)</b></tt></a><p>

Removes the Base 64 content coding from the string <tt>content</tt>, and
returns the result as a string. <p>

<a name="mod.html#Code.escape"><tt><b>Code.escape(</b>content<b>)</b></tt></a><p>

Applies the URL escaping content  coding to the string <tt>content</tt>.
Each byte in <tt>content</tt> is encoded as a percent character followed
by its two byte hexadecimal representation. <p>

Examples: <br>
<blockquote>
<pre>
code = Code.escape("/#?;")
-- code = "%2f%23%3f%3b"

</pre>
</blockquote>

<a name="mod.html#Code.unescape"><tt><b>Code.unescape(</b>content<b>)</b></tt></a><p>

Removes   the   URL   escaping    content   coding   from   the   string
<tt>content</tt>, and returns the result as a string. <p>

<a name="mod.html#Code.hexa"><tt><b>Code.hexa(</b>content<b>)</b></tt></a><p>

Applies the  hexadecimal content coding to  the string <tt>content</tt>.
Each byte  in <tt>content</tt>  is encoded as  its two  byte hexadecimal
representation. <p>

Examples: <br>
<blockquote>
<pre>
code = Code.hexa("\16\32\255")
-- code = "1020ff"

</pre>
</blockquote>

<a name="mod.html#Code.unhexa"><tt><b>Code.unhexa(</b>content<b>)</b></tt></a><p>

Removes the hexadecimal content coding from the string <tt>content</tt>,
and returns the result as a string. <p>

<hr>
<p align=center>
<a href="home.html">home</a> &middot;
<a href="home.html#down">download</a> &middot;
<a href="home.html#whatis">what is</a> &middot;
<a href="intro.html">introduction</a> &middot;
<a href="func.html">functions</a> &middot;
<a href="mod.html">modules</a> &middot;
<a href="idx.html">index</a> 
<p>

<table summary="Best Viewed on Any Browser and Created with Vim" align=center>
<tr> 
<td align=center> <img alt="Created with Vim" src="vim.png">
<td align=center> and
<td align=center> <img alt="Best Viewed on Any Browser" src="anybrowser.png">
<tr> <td colspan=3 align=center>
<small>
Last modified by Diego Nehab on <br>
Thu Sep 27 16:18:27 EST 2001
</small>
</table>

</body>
</html>
